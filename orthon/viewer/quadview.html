<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORTHON Quad View</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #08080c;
            color: rgba(255,255,255,0.9);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            height: calc(100vh - 56px);
            gap: 1px;
            background: rgba(255,255,255,0.1);
        }
        .panel {
            position: relative;
            background: #0a0a10;
        }
        .panel-label {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 10;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 6px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
        }
        .panel-label.signals { color: #a0aec0; }
        .panel-label.geometry { color: #48bb78; }
        .panel-label.dynamics { color: #ed8936; }
        .panel-label.mechanics { color: #9f7aea; }
        canvas { width: 100%; height: 100%; display: block; }
        .timeline {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 24px;
            background: #0a0a10;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.7);
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.1); }
        button.active { background: #3182ce; border-color: #3182ce; color: white; }
        input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3182ce;
            border-radius: 50%;
            cursor: pointer;
        }
        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            min-width: 100px;
        }
        select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="grid">
        <div class="panel">
            <div class="panel-label signals">Signals</div>
            <canvas id="signalsCanvas"></canvas>
        </div>
        <div class="panel">
            <div class="panel-label geometry">Geometry</div>
            <canvas id="geometryCanvas"></canvas>
        </div>
        <div class="panel">
            <div class="panel-label dynamics">Dynamics</div>
            <canvas id="dynamicsCanvas"></canvas>
        </div>
        <div class="panel">
            <div class="panel-label mechanics">Mechanics</div>
            <canvas id="mechanicsCanvas"></canvas>
        </div>
    </div>
    <div class="timeline">
        <button id="playBtn">▶ Play</button>
        <select id="speedSelect">
            <option value="0.1">0.1x</option>
            <option value="0.25">0.25x</option>
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x</option>
            <option value="2">2x</option>
            <option value="5">5x</option>
        </select>
        <input type="range" id="timeline" min="0" max="100" value="0">
        <span class="time-display" id="timeDisplay">t = 0 / 100</span>
        <select id="entitySelect"></select>
        <select id="metricSelect">
            <option value="position">Position</option>
            <option value="velocity">Velocity</option>
            <option value="acceleration">Acceleration</option>
            <option value="cumulative">Cumulative</option>
        </select>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================================
        // State
        // ============================================================
        let rawData = null;
        let currentEntity = null;
        let currentTime = 0;
        let maxTime = 100;
        let isPlaying = false;
        let playbackSpeed = 1;
        let currentMetric = 'position';
        const TRAIL_LENGTH = 50;

        // Four panels
        const panels = {
            signals: { scene: null, camera: null, renderer: null, color: 0xa0aec0, trail: [], fullPath: null },
            geometry: { scene: null, camera: null, renderer: null, color: 0x48bb78, trail: [], fullPath: null },
            dynamics: { scene: null, camera: null, renderer: null, color: 0xed8936, trail: [], fullPath: null },
            mechanics: { scene: null, camera: null, renderer: null, color: 0x9f7aea, trail: [], fullPath: null }
        };

        // ============================================================
        // Load Data
        // ============================================================
        async function loadData() {
            const response = await fetch('data/manifold.json');
            rawData = await response.json();

            // Populate entities
            const entities = [...new Set(rawData.trajectory.map(t => t.entity_id))];
            const select = document.getElementById('entitySelect');
            entities.forEach(e => {
                const opt = document.createElement('option');
                opt.value = e;
                opt.textContent = e;
                select.appendChild(opt);
            });
            currentEntity = entities[0];
            updateMaxTime();
        }

        function updateMaxTime() {
            const entityData = rawData.trajectory.filter(t => t.entity_id === currentEntity);
            maxTime = entityData.length - 1;
            document.getElementById('timeline').max = maxTime;
        }

        // ============================================================
        // Generate Layer Data (normalized 3D coordinates)
        // ============================================================
        function applyMetricTransform(positions) {
            // Apply selected metric transformation
            const n = positions.length;

            switch(currentMetric) {
                case 'position':
                    return positions;

                case 'velocity':
                    // First derivative
                    return positions.map((p, i) => {
                        if (i === 0) return [0, 0, 0];
                        const prev = positions[i - 1];
                        return [p[0] - prev[0], p[1] - prev[1], p[2] - prev[2]];
                    });

                case 'acceleration':
                    // Second derivative
                    const vel = positions.map((p, i) => {
                        if (i === 0) return [0, 0, 0];
                        const prev = positions[i - 1];
                        return [p[0] - prev[0], p[1] - prev[1], p[2] - prev[2]];
                    });
                    return vel.map((v, i) => {
                        if (i === 0) return [0, 0, 0];
                        const prev = vel[i - 1];
                        return [v[0] - prev[0], v[1] - prev[1], v[2] - prev[2]];
                    });

                case 'cumulative':
                    // Running sum (integral)
                    let sum = [0, 0, 0];
                    return positions.map(p => {
                        sum = [sum[0] + p[0] * 0.1, sum[1] + p[1] * 0.1, sum[2] + p[2] * 0.1];
                        return [...sum];
                    });

                default:
                    return positions;
            }
        }

        function getLayerData(layer, entityData) {
            // Each layer transforms the same base data differently
            // All normalized to [-3, 3] coordinate space

            const rawPositions = entityData.map(d => d.position);
            const positions = applyMetricTransform(rawPositions);
            const n = positions.length;

            switch(layer) {
                case 'signals':
                    // Raw signal space embedding
                    return normalizePositions(positions);

                case 'geometry':
                    // COMPLETE MANIFOLD: all metrics at current window
                    // Returns multiple points representing the full manifold structure
                    // Each point = one metric dimension, positions show relationships
                    return positions; // Will be handled specially in updatePanel

                case 'dynamics':
                    // DYNAMICS: velocity, acceleration, stability
                    // X = velocity magnitude
                    // Y = acceleration magnitude
                    // Z = time
                    return normalizePositions(positions.map((p, i) => {
                        let velocity = 0, acceleration = 0;
                        if (i > 0) {
                            const prev = positions[i - 1];
                            velocity = Math.sqrt(
                                (p[0]-prev[0])**2 + (p[1]-prev[1])**2 + (p[2]-prev[2])**2
                            );
                        }
                        if (i > 1) {
                            const prev = positions[i - 1];
                            const prev2 = positions[i - 2];
                            const v1 = Math.sqrt(
                                (p[0]-prev[0])**2 + (p[1]-prev[1])**2 + (p[2]-prev[2])**2
                            );
                            const v0 = Math.sqrt(
                                (prev[0]-prev2[0])**2 + (prev[1]-prev2[1])**2 + (prev[2]-prev2[2])**2
                            );
                            acceleration = v1 - v0;
                        }
                        return [
                            velocity * 20,
                            acceleration * 50,
                            i / n * 6 - 3
                        ];
                    }));

                case 'mechanics':
                    // MECHANICS: energy, momentum, phase
                    // X = kinetic energy (velocity^2)
                    // Y = cumulative energy (integral)
                    // Z = phase angle
                    let cumEnergy = 0;
                    return normalizePositions(positions.map((p, i) => {
                        let kineticEnergy = 0;
                        if (i > 0) {
                            const prev = positions[i - 1];
                            const v2 = (p[0]-prev[0])**2 + (p[1]-prev[1])**2 + (p[2]-prev[2])**2;
                            kineticEnergy = v2;
                            cumEnergy += Math.sqrt(v2) * 0.1;
                        }
                        const phase = Math.atan2(p[2], p[0]);
                        return [
                            kineticEnergy * 100,
                            cumEnergy,
                            phase
                        ];
                    }));
            }
        }

        function normalizePositions(positions) {
            // Normalize all positions to [-3, 3] range
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            positions.forEach(p => {
                minX = Math.min(minX, p[0]); maxX = Math.max(maxX, p[0]);
                minY = Math.min(minY, p[1]); maxY = Math.max(maxY, p[1]);
                minZ = Math.min(minZ, p[2]); maxZ = Math.max(maxZ, p[2]);
            });

            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const rangeZ = maxZ - minZ || 1;

            return positions.map(p => [
                ((p[0] - minX) / rangeX - 0.5) * 6,
                ((p[1] - minY) / rangeY - 0.5) * 6,
                ((p[2] - minZ) / rangeZ - 0.5) * 6
            ]);
        }

        // ============================================================
        // Initialize Three.js for each panel
        // ============================================================
        function initPanel(name) {
            const canvas = document.getElementById(name + 'Canvas');
            const container = canvas.parentElement;
            const panel = panels[name];

            panel.scene = new THREE.Scene();
            panel.scene.background = new THREE.Color(0x08080c);

            panel.camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
            panel.camera.position.set(8, 6, 8);
            panel.camera.lookAt(0, 0, 0);

            panel.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            panel.renderer.setSize(container.clientWidth, container.clientHeight);
            panel.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Subtle grid
            const grid = new THREE.GridHelper(8, 16, 0x151520, 0x0c0c14);
            grid.position.y = -3;
            panel.scene.add(grid);

            // Axes hint
            const axesSize = 0.5;
            const axesMat = new THREE.LineBasicMaterial({ color: 0x333340 });
            const axesGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-3, -3, -3), new THREE.Vector3(-3 + axesSize, -3, -3),
                new THREE.Vector3(-3, -3, -3), new THREE.Vector3(-3, -3 + axesSize, -3),
                new THREE.Vector3(-3, -3, -3), new THREE.Vector3(-3, -3, -3 + axesSize)
            ]);
            panel.scene.add(new THREE.LineSegments(axesGeom, axesMat));

            // Mouse controls
            let isDragging = false, prevX = 0, prevY = 0;
            canvas.onmousedown = (e) => { isDragging = true; prevX = e.clientX; prevY = e.clientY; };
            canvas.onmouseup = () => isDragging = false;
            canvas.onmouseleave = () => isDragging = false;
            canvas.onmousemove = (e) => {
                if (!isDragging) return;
                const spherical = new THREE.Spherical().setFromVector3(panel.camera.position);
                spherical.theta -= (e.clientX - prevX) * 0.01;
                spherical.phi -= (e.clientY - prevY) * 0.01;
                spherical.phi = Math.max(0.2, Math.min(Math.PI - 0.2, spherical.phi));
                panel.camera.position.setFromSpherical(spherical);
                panel.camera.lookAt(0, 0, 0);
                prevX = e.clientX; prevY = e.clientY;
            };
            canvas.onwheel = (e) => {
                e.preventDefault();
                panel.camera.position.multiplyScalar(e.deltaY > 0 ? 1.08 : 0.92);
            };
        }

        // ============================================================
        // Update Panel Visuals
        // ============================================================
        function updatePanel(name) {
            const panel = panels[name];
            const entityData = rawData.trajectory.filter(t => t.entity_id === currentEntity);

            // Clear old objects (except grid and axes)
            panel.scene.children = panel.scene.children.filter(c =>
                c.type === 'GridHelper' || c.type === 'LineSegments'
            );

            if (name === 'geometry') {
                // GEOMETRY: Complete manifold structure at current time
                // Show multiple windows simultaneously with smooth curves
                updateGeometryManifold(panel, entityData);
                return;
            }

            const layerData = getLayerData(name, entityData);

            if (isPlaying) {
                // TRAIL MODE: Show trail up to current time
                const trailStart = Math.max(0, currentTime - TRAIL_LENGTH);
                const trailEnd = Math.min(currentTime + 1, layerData.length);
                const trailPoints = layerData.slice(trailStart, trailEnd).map(p => new THREE.Vector3(...p));

                if (trailPoints.length > 1) {
                    // Trail with fade
                    const trailGeom = new THREE.BufferGeometry().setFromPoints(trailPoints);
                    const colors = [];
                    for (let i = 0; i < trailPoints.length; i++) {
                        const alpha = i / trailPoints.length;
                        const c = new THREE.Color(panel.color);
                        colors.push(c.r * alpha, c.g * alpha, c.b * alpha);
                    }
                    trailGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    const trailMat = new THREE.LineBasicMaterial({ vertexColors: true });
                    panel.scene.add(new THREE.Line(trailGeom, trailMat));
                }

                // Current position sphere
                if (currentTime < layerData.length) {
                    const pos = layerData[Math.floor(currentTime)];
                    const sphereGeom = new THREE.SphereGeometry(0.12, 16, 16);
                    const sphereMat = new THREE.MeshBasicMaterial({ color: panel.color });
                    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                    sphere.position.set(...pos);
                    panel.scene.add(sphere);
                }
            } else {
                // FULL MAP MODE: Show entire trajectory
                const points = layerData.map(p => new THREE.Vector3(...p));
                const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({ color: panel.color, opacity: 0.6, transparent: true });
                panel.scene.add(new THREE.Line(lineGeom, lineMat));

                // Dots at intervals
                const dotGeom = new THREE.SphereGeometry(0.04, 8, 8);
                const dotMat = new THREE.MeshBasicMaterial({ color: panel.color });
                for (let i = 0; i < points.length; i += Math.max(1, Math.floor(points.length / 30))) {
                    const dot = new THREE.Mesh(dotGeom, dotMat);
                    dot.position.copy(points[i]);
                    panel.scene.add(dot);
                }

                // Current position marker (larger)
                if (currentTime < layerData.length) {
                    const pos = layerData[Math.floor(currentTime)];
                    const markerGeom = new THREE.SphereGeometry(0.1, 16, 16);
                    const markerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const marker = new THREE.Mesh(markerGeom, markerMat);
                    marker.position.set(...pos);
                    panel.scene.add(marker);
                }
            }
        }

        function updateGeometryManifold(panel, entityData) {
            // GEOMETRY: Beautiful flowing manifold of ALL metrics
            const WINDOW_SIZE = 8;
            const STEP = 3;
            const t = Math.floor(currentTime);
            const n = entityData.length;

            if (n < WINDOW_SIZE + 4) return;

            // Compute metrics for ALL windows
            const allMetrics = [];

            for (let w = 0; w < n - WINDOW_SIZE; w += STEP) {
                const windowData = entityData.slice(w, w + WINDOW_SIZE);
                const positions = windowData.map(d => d.position);

                // Mean
                const mean = [0, 0, 0];
                positions.forEach(p => { mean[0] += p[0]; mean[1] += p[1]; mean[2] += p[2]; });
                mean[0] /= positions.length; mean[1] /= positions.length; mean[2] /= positions.length;

                // Variance
                let variance = 0;
                positions.forEach(p => {
                    variance += (p[0]-mean[0])**2 + (p[1]-mean[1])**2 + (p[2]-mean[2])**2;
                });
                variance = Math.sqrt(variance / positions.length) || 0.01;

                // Curvature
                let curvature = 0.01;
                for (let i = 1; i < positions.length - 1; i++) {
                    const prev = positions[i-1], curr = positions[i], next = positions[i+1];
                    curvature += Math.sqrt(
                        (next[0] - 2*curr[0] + prev[0])**2 +
                        (next[1] - 2*curr[1] + prev[1])**2 +
                        (next[2] - 2*curr[2] + prev[2])**2
                    ) || 0;
                }
                curvature = (curvature / positions.length) || 0.01;

                // Velocity
                let velocity = 0.01;
                for (let i = 1; i < positions.length; i++) {
                    const prev = positions[i-1], curr = positions[i];
                    velocity += Math.sqrt(
                        (curr[0]-prev[0])**2 + (curr[1]-prev[1])**2 + (curr[2]-prev[2])**2
                    ) || 0;
                }

                // Coherence
                const coherence = windowData.reduce((sum, d) => sum + (d.coherence || 0.5), 0) / windowData.length;

                allMetrics.push({ w, variance, curvature, velocity, coherence });
            }

            if (allMetrics.length < 4) return;

            // Normalize
            const maxVar = Math.max(...allMetrics.map(m => m.variance), 0.1);
            const maxCurv = Math.max(...allMetrics.map(m => m.curvature), 0.1);
            const maxVel = Math.max(...allMetrics.map(m => m.velocity), 0.1);

            // Create manifold points - elegant helix shape
            const manifoldPoints = allMetrics.map((m, i) => {
                const progress = i / (allMetrics.length - 1);
                const normVar = m.variance / maxVar;
                const normCurv = m.curvature / maxCurv;
                const normVel = m.velocity / maxVel;

                // Helix with varying radius based on metrics
                const angle = progress * Math.PI * 2.5;
                const radius = 1.5 + normVar * 1.5;

                return new THREE.Vector3(
                    Math.cos(angle) * radius,
                    (progress - 0.5) * 5,
                    Math.sin(angle) * radius
                );
            });

            // Smooth curve through all points
            const curve = new THREE.CatmullRomCurve3(manifoldPoints);
            const curvePoints = curve.getPoints(150);

            // Main manifold line - thick and colored
            const lineGeom = new THREE.BufferGeometry().setFromPoints(curvePoints);
            const colors = [];
            for (let i = 0; i < curvePoints.length; i++) {
                const progress = i / curvePoints.length;
                const metricIdx = Math.min(Math.floor(progress * allMetrics.length), allMetrics.length - 1);
                const m = allMetrics[metricIdx];
                const c = new THREE.Color();
                c.setHSL(0.35 - m.coherence * 0.35, 0.8, 0.55);
                colors.push(c.r, c.g, c.b);
            }
            lineGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
            panel.scene.add(new THREE.Line(lineGeom, lineMat));

            // Add dots along the manifold
            const dotGeom = new THREE.SphereGeometry(0.06, 8, 8);
            for (let i = 0; i < manifoldPoints.length; i++) {
                const m = allMetrics[i];
                const c = new THREE.Color();
                c.setHSL(0.35 - m.coherence * 0.35, 0.7, 0.5);
                const dotMat = new THREE.MeshBasicMaterial({ color: c });
                const dot = new THREE.Mesh(dotGeom, dotMat);
                dot.position.copy(manifoldPoints[i]);
                panel.scene.add(dot);
            }

            // Current position - bright white marker
            const currentProgress = t / n;
            const currentIdx = Math.min(Math.floor(currentProgress * manifoldPoints.length), manifoldPoints.length - 1);
            const currentPos = manifoldPoints[currentIdx];

            const markerGeom = new THREE.SphereGeometry(0.15, 16, 16);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeom, markerMat);
            marker.position.copy(currentPos);
            panel.scene.add(marker);

            // Glow around marker
            const glowGeom = new THREE.SphereGeometry(0.25, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            const glow = new THREE.Mesh(glowGeom, glowMat);
            glow.position.copy(currentPos);
            panel.scene.add(glow);
        }

        function updateAllPanels() {
            Object.keys(panels).forEach(updatePanel);
        }

        // ============================================================
        // Animation Loop
        // ============================================================
        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                currentTime += 0.3 * playbackSpeed;
                if (currentTime > maxTime) currentTime = 0;
                document.getElementById('timeline').value = Math.floor(currentTime);
                document.getElementById('timeDisplay').textContent = `t = ${Math.floor(currentTime)} / ${maxTime}`;
                updateAllPanels();
            }

            // Render all panels
            Object.values(panels).forEach(p => {
                if (p.renderer && p.scene && p.camera) {
                    p.renderer.render(p.scene, p.camera);
                }
            });
        }

        function goToTime(t) {
            currentTime = t;
            document.getElementById('timeline').value = t;
            document.getElementById('timeDisplay').textContent = `t = ${t} / ${maxTime}`;
            updateAllPanels();
        }

        // ============================================================
        // Controls
        // ============================================================
        function setupControls() {
            document.getElementById('playBtn').onclick = () => {
                isPlaying = !isPlaying;
                document.getElementById('playBtn').textContent = isPlaying ? '❚❚ Pause' : '▶ Play';
                document.getElementById('playBtn').classList.toggle('active', isPlaying);
                updateAllPanels();
            };

            document.getElementById('timeline').oninput = (e) => goToTime(parseInt(e.target.value));

            document.getElementById('entitySelect').onchange = (e) => {
                currentEntity = e.target.value;
                updateMaxTime();
                currentTime = 0;
                goToTime(0);
            };

            document.getElementById('speedSelect').onchange = (e) => {
                playbackSpeed = parseFloat(e.target.value);
            };

            document.getElementById('metricSelect').onchange = (e) => {
                currentMetric = e.target.value;
                updateAllPanels();
            };

            window.addEventListener('resize', () => {
                Object.keys(panels).forEach(name => {
                    const canvas = document.getElementById(name + 'Canvas');
                    const container = canvas.parentElement;
                    panels[name].camera.aspect = container.clientWidth / container.clientHeight;
                    panels[name].camera.updateProjectionMatrix();
                    panels[name].renderer.setSize(container.clientWidth, container.clientHeight);
                });
            });
        }

        // ============================================================
        // Initialize
        // ============================================================
        async function init() {
            await loadData();

            Object.keys(panels).forEach(initPanel);
            setupControls();
            updateAllPanels();
            animate();
        }

        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORTHON Manifold Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: rgba(255,255,255,0.9);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(15,15,25,0.95);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .header h1 {
            font-size: 16px;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
        }
        .controls {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        select:hover { border-color: rgba(255,255,255,0.4); }
        .container {
            display: flex;
            height: calc(100vh - 100px);
        }
        .panel {
            flex: 1;
            position: relative;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .panel:last-child { border-right: none; }
        .panel-header {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.4);
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }
        canvas { width: 100%; height: 100%; }
        .timeline {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(15,15,25,0.95);
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .timeline button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.7);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .timeline button:hover { background: rgba(255,255,255,0.1); }
        .timeline button.active { background: #3182ce; border-color: #3182ce; }
        .timeline input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        .timeline input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3182ce;
            border-radius: 50%;
            cursor: pointer;
        }
        .time-display {
            font-family: monospace;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            min-width: 80px;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.6);
            border-radius: 6px;
            font-size: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .status {
            position: fixed;
            bottom: 60px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            color: rgba(255,255,255,0.6);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ORTHON Phase Space</h1>
        <div class="controls">
            <div class="control-group">
                <label>Manifold</label>
                <select id="manifoldMath">
                    <option value="pca">PCA</option>
                    <option value="normalized">Normalized</option>
                    <option value="zscore">Z-Score</option>
                    <option value="minmax">Min-Max</option>
                </select>
            </div>
            <div class="control-group">
                <label>Signals</label>
                <select id="signalMath">
                    <option value="deviation">Deviation</option>
                    <option value="raw">Raw Values</option>
                    <option value="normalized">Normalized</option>
                    <option value="rank">Rank</option>
                </select>
            </div>
            <div class="control-group">
                <label>Entity</label>
                <select id="entitySelect"></select>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="panel" id="manifoldPanel">
            <div class="panel-header">MANIFOLD (3D)</div>
            <canvas id="manifoldCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background:#3182ce"></div>
                    <span>Stable</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#d69e2e"></div>
                    <span>Transitional</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#e53e3e"></div>
                    <span>Critical</span>
                </div>
            </div>
        </div>
        <div class="panel" id="signalPanel">
            <div class="panel-header">SIGNALS (2D)</div>
            <canvas id="signalCanvas"></canvas>
        </div>
    </div>

    <div class="timeline">
        <button id="playBtn">▶ Play</button>
        <input type="range" id="timeline" min="0" max="100" value="0">
        <span class="time-display" id="timeDisplay">t = 0</span>
    </div>

    <div class="status" id="status">Loading DuckDB...</div>

    <!-- DuckDB WASM -->
    <script src="https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb-browser-mvp.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // State
        let db = null;
        let conn = null;
        let rawData = null;
        let currentEntity = null;
        let currentTime = 0;
        let isPlaying = false;
        let maxTime = 100;

        // Three.js
        let scene, camera, renderer, trajectoryLine;

        // 2D Canvas
        let signalCtx;

        // ============================================================
        // Initialize DuckDB
        // ============================================================
        async function initDuckDB() {
            try {
                updateStatus('Initializing DuckDB...');

                // For now, load from JSON (DuckDB WASM setup is complex)
                // In production, would use actual DuckDB with parquet
                const response = await fetch('data/manifold.json');
                rawData = await response.json();

                updateStatus(`Loaded ${rawData.trajectory.length} points`);

                // Populate entity dropdown
                const entities = [...new Set(rawData.trajectory.map(t => t.entity_id))];
                const entitySelect = document.getElementById('entitySelect');
                entities.forEach(e => {
                    const opt = document.createElement('option');
                    opt.value = e;
                    opt.textContent = e;
                    entitySelect.appendChild(opt);
                });
                currentEntity = entities[0];

                // Set max time
                const entityData = rawData.trajectory.filter(t => t.entity_id === currentEntity);
                maxTime = entityData.length - 1;
                document.getElementById('timeline').max = maxTime;

                return true;
            } catch (e) {
                updateStatus('Error: ' + e.message);
                return false;
            }
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        // ============================================================
        // Math Functions (coordinate transformations)
        // ============================================================
        const manifoldMath = {
            pca: (data) => data.map(d => d.position),

            normalized: (data) => {
                const positions = data.map(d => d.position);
                const mins = [Infinity, Infinity, Infinity];
                const maxs = [-Infinity, -Infinity, -Infinity];
                positions.forEach(p => {
                    for (let i = 0; i < 3; i++) {
                        mins[i] = Math.min(mins[i], p[i]);
                        maxs[i] = Math.max(maxs[i], p[i]);
                    }
                });
                return positions.map(p => p.map((v, i) =>
                    (maxs[i] - mins[i]) > 0 ? (v - mins[i]) / (maxs[i] - mins[i]) * 6 - 3 : 0
                ));
            },

            zscore: (data) => {
                const positions = data.map(d => d.position);
                const means = [0, 0, 0];
                const stds = [0, 0, 0];
                positions.forEach(p => { for (let i = 0; i < 3; i++) means[i] += p[i]; });
                means.forEach((m, i) => means[i] = m / positions.length);
                positions.forEach(p => { for (let i = 0; i < 3; i++) stds[i] += (p[i] - means[i]) ** 2; });
                stds.forEach((s, i) => stds[i] = Math.sqrt(s / positions.length) || 1);
                return positions.map(p => p.map((v, i) => (v - means[i]) / stds[i]));
            },

            minmax: (data) => manifoldMath.normalized(data)
        };

        const signalMath = {
            deviation: (signals, t) => {
                // Distance from mean position
                const positions = signals.map(s => s.trajectory[t] || [0, 0, 0]);
                const mean = [0, 0, 0];
                positions.forEach(p => { for (let i = 0; i < 3; i++) mean[i] += p[i]; });
                mean.forEach((m, i) => mean[i] = m / positions.length);

                return signals.map((s, idx) => {
                    const p = positions[idx];
                    const dist = Math.sqrt((p[0]-mean[0])**2 + (p[1]-mean[1])**2 + (p[2]-mean[2])**2);
                    return { id: s.id, x: p[0] - mean[0], y: p[2] - mean[2], value: dist, role: s.role };
                });
            },

            raw: (signals, t) => {
                return signals.map(s => {
                    const p = s.trajectory[t] || [0, 0, 0];
                    return { id: s.id, x: p[0], y: p[2], value: p[1], role: s.role };
                });
            },

            normalized: (signals, t) => {
                const raw = signalMath.raw(signals, t);
                const maxVal = Math.max(...raw.map(r => Math.abs(r.value)), 0.1);
                return raw.map(r => ({ ...r, x: r.x / maxVal * 2, y: r.y / maxVal * 2, value: r.value / maxVal }));
            },

            rank: (signals, t) => {
                const raw = signalMath.raw(signals, t);
                const sorted = [...raw].sort((a, b) => b.value - a.value);
                return raw.map(r => {
                    const rank = sorted.findIndex(s => s.id === r.id);
                    return { ...r, x: (rank / raw.length - 0.5) * 4, y: r.y, value: rank };
                });
            }
        };

        // ============================================================
        // 3D Manifold Rendering
        // ============================================================
        function initThreeJS() {
            const canvas = document.getElementById('manifoldCanvas');
            const container = canvas.parentElement;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a12);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(6, 4, 6);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Lights
            scene.add(new THREE.AmbientLight(0x404060, 0.5));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(5, 10, 5);
            scene.add(light);

            // Grid
            const grid = new THREE.GridHelper(10, 20, 0x1a1a2e, 0x0f0f1a);
            grid.position.y = -2;
            scene.add(grid);

            // Mouse rotation
            let isDragging = false, prevX = 0, prevY = 0;
            canvas.onmousedown = (e) => { isDragging = true; prevX = e.clientX; prevY = e.clientY; };
            canvas.onmouseup = () => isDragging = false;
            canvas.onmouseleave = () => isDragging = false;
            canvas.onmousemove = (e) => {
                if (!isDragging) return;
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta -= (e.clientX - prevX) * 0.005;
                spherical.phi -= (e.clientY - prevY) * 0.005;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                prevX = e.clientX; prevY = e.clientY;
            };
            canvas.onwheel = (e) => {
                e.preventDefault();
                camera.position.multiplyScalar(e.deltaY > 0 ? 1.1 : 0.9);
            };

            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function updateManifold() {
            if (!rawData) return;

            // Remove old trajectory
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
            }

            // Get entity data
            const entityData = rawData.trajectory.filter(t => t.entity_id === currentEntity);
            if (entityData.length === 0) return;

            // Apply selected math
            const mathType = document.getElementById('manifoldMath').value;
            const positions = manifoldMath[mathType](entityData);

            // Create line
            const points = positions.map(p => new THREE.Vector3(p[0], p[1], p[2]));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.LineBasicMaterial({ color: 0x888888 });
            trajectoryLine = new THREE.Line(geometry, material);
            scene.add(trajectoryLine);

            // Add current position marker
            const markerGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const t = Math.min(currentTime, positions.length - 1);
            const regime = entityData[t]?.regime || 'stable';
            const color = regime === 'critical' ? 0xe53e3e : regime === 'transitional' ? 0xd69e2e : 0x3182ce;
            const markerMat = new THREE.MeshBasicMaterial({ color });
            const marker = new THREE.Mesh(markerGeom, markerMat);
            marker.position.set(positions[t][0], positions[t][1], positions[t][2]);
            marker.name = 'currentMarker';

            // Remove old marker
            const oldMarker = scene.getObjectByName('currentMarker');
            if (oldMarker) scene.remove(oldMarker);
            scene.add(marker);
        }

        // ============================================================
        // 2D Signal Rendering
        // ============================================================
        function initSignalCanvas() {
            const canvas = document.getElementById('signalCanvas');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            signalCtx = canvas.getContext('2d');
        }

        function updateSignals() {
            if (!rawData || !signalCtx) return;

            const canvas = document.getElementById('signalCanvas');
            const w = canvas.width;
            const h = canvas.height;

            // Clear
            signalCtx.fillStyle = '#0a0a12';
            signalCtx.fillRect(0, 0, w, h);

            // Get signal data at current time
            const mathType = document.getElementById('signalMath').value;
            const t = Math.min(currentTime, (rawData.signals[Object.keys(rawData.signals)[0]]?.trajectory?.length || 1) - 1);

            // Convert signals object to array
            const signalArray = Object.entries(rawData.signals).map(([id, data]) => ({
                id,
                trajectory: data.trajectory,
                role: data.role
            }));

            if (signalArray.length === 0 || !signalArray[0].trajectory?.length) {
                signalCtx.fillStyle = 'rgba(255,255,255,0.3)';
                signalCtx.font = '12px sans-serif';
                signalCtx.textAlign = 'center';
                signalCtx.fillText('No signal data', w/2, h/2);
                return;
            }

            const signalPositions = signalMath[mathType](signalArray, t);

            // Find bounds for scaling
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            signalPositions.forEach(s => {
                minX = Math.min(minX, s.x); maxX = Math.max(maxX, s.x);
                minY = Math.min(minY, s.y); maxY = Math.max(maxY, s.y);
            });
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const margin = 60;

            // Draw axes
            signalCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            signalCtx.beginPath();
            signalCtx.moveTo(margin, h/2);
            signalCtx.lineTo(w - margin, h/2);
            signalCtx.moveTo(w/2, margin);
            signalCtx.lineTo(w/2, h - margin);
            signalCtx.stroke();

            // Draw signals
            const roleColors = {
                'SOURCE': '#ff6b6b',
                'SINK': '#4ecdc4',
                'CONDUIT': '#a0aec0'
            };

            signalPositions.forEach(s => {
                const px = margin + ((s.x - minX) / rangeX) * (w - 2 * margin);
                const py = margin + ((s.y - minY) / rangeY) * (h - 2 * margin);
                const color = roleColors[s.role] || '#a0aec0';

                // Glow
                const grad = signalCtx.createRadialGradient(px, py, 0, px, py, 20);
                grad.addColorStop(0, color + '40');
                grad.addColorStop(1, 'transparent');
                signalCtx.fillStyle = grad;
                signalCtx.beginPath();
                signalCtx.arc(px, py, 20, 0, Math.PI * 2);
                signalCtx.fill();

                // Dot
                signalCtx.fillStyle = color;
                signalCtx.beginPath();
                signalCtx.arc(px, py, 4, 0, Math.PI * 2);
                signalCtx.fill();

                // Label
                signalCtx.fillStyle = 'rgba(255,255,255,0.5)';
                signalCtx.font = '9px monospace';
                signalCtx.textAlign = 'center';
                const shortName = s.id.replace('temp_', 'T_').replace('press_', 'P_').replace('speed_', 'S_');
                signalCtx.fillText(shortName, px, py - 10);
            });

            // Math type label
            signalCtx.fillStyle = 'rgba(255,255,255,0.3)';
            signalCtx.font = '10px sans-serif';
            signalCtx.textAlign = 'right';
            signalCtx.fillText(`Math: ${mathType}`, w - 10, h - 10);
        }

        // ============================================================
        // Animation
        // ============================================================
        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                currentTime = (currentTime + 0.3) % (maxTime + 1);
                document.getElementById('timeline').value = Math.floor(currentTime);
                document.getElementById('timeDisplay').textContent = `t = ${Math.floor(currentTime)}`;
                updateManifold();
                updateSignals();
            }

            // Slow auto-rotate
            if (!isPlaying) {
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta += 0.001;
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        function goToTime(t) {
            currentTime = t;
            document.getElementById('timeline').value = t;
            document.getElementById('timeDisplay').textContent = `t = ${t}`;
            updateManifold();
            updateSignals();
        }

        // ============================================================
        // Event Handlers
        // ============================================================
        function setupControls() {
            document.getElementById('playBtn').onclick = () => {
                isPlaying = !isPlaying;
                document.getElementById('playBtn').textContent = isPlaying ? '❚❚ Pause' : '▶ Play';
                document.getElementById('playBtn').classList.toggle('active', isPlaying);
            };

            document.getElementById('timeline').oninput = (e) => goToTime(parseInt(e.target.value));

            document.getElementById('manifoldMath').onchange = () => updateManifold();
            document.getElementById('signalMath').onchange = () => updateSignals();

            document.getElementById('entitySelect').onchange = (e) => {
                currentEntity = e.target.value;
                const entityData = rawData.trajectory.filter(t => t.entity_id === currentEntity);
                maxTime = entityData.length - 1;
                document.getElementById('timeline').max = maxTime;
                currentTime = 0;
                goToTime(0);
            };
        }

        // ============================================================
        // Initialize
        // ============================================================
        async function init() {
            const success = await initDuckDB();
            if (!success) return;

            initThreeJS();
            initSignalCanvas();
            setupControls();

            updateManifold();
            updateSignals();

            animate();

            updateStatus('Ready');
            setTimeout(() => {
                document.getElementById('status').style.display = 'none';
            }, 2000);
        }

        init();
    </script>
</body>
</html>

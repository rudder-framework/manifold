<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORTHON Geometry</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #08080c;
            color: rgba(255,255,255,0.9);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        #canvas { width: 100%; height: calc(100vh - 50px); display: block; }
        .controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 10px 24px;
            background: #0a0a10;
            border-top: 1px solid rgba(255,255,255,0.1);
            height: 50px;
        }
        button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.7);
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: rgba(255,255,255,0.1); }
        button.active { background: #3182ce; border-color: #3182ce; color: white; }
        input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3182ce;
            border-radius: 50%;
            cursor: pointer;
        }
        .info {
            font-family: monospace;
            font-size: 11px;
            color: rgba(255,255,255,0.5);
        }
        .legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 11px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#ff6b6b"></div> Variance</div>
        <div class="legend-item"><div class="legend-dot" style="background:#4ecdc4"></div> Curvature</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffe66d"></div> Velocity</div>
        <div class="legend-item"><div class="legend-dot" style="background:#95e1d3"></div> Coherence</div>
        <div class="legend-item"><div class="legend-dot" style="background:#f38181"></div> Acceleration</div>
        <div class="legend-item"><div class="legend-dot" style="background:#aa96da"></div> Entropy</div>
    </div>

    <div class="controls">
        <button id="playBtn">▶ Play</button>
        <input type="range" id="timeline" min="0" max="100" value="0">
        <span class="info" id="info">Window 0 / 20</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // State
        let rawData = null;
        let entityData = null;
        let timeOffset = 0;
        let maxTimeOffset = 0;
        let isPlaying = false;
        let lastFrameTime = 0;
        const FRAME_DELAY = 200;  // ms between animation frames
        const NUM_WINDOWS = 20;
        const WINDOW_SIZE = 8;

        // Three.js
        let scene, camera, renderer;
        let metricPoints = {};  // Store points by metric type

        // Metric colors
        const METRICS = {
            variance:     { color: 0xff6b6b, idx: 0 },
            curvature:    { color: 0x4ecdc4, idx: 1 },
            velocity:     { color: 0xffe66d, idx: 2 },
            coherence:    { color: 0x95e1d3, idx: 3 },
            acceleration: { color: 0xf38181, idx: 4 },
            entropy:      { color: 0xaa96da, idx: 5 }
        };

        async function loadData() {
            const response = await fetch('data/manifold.json');
            rawData = await response.json();

            entityData = rawData.trajectory;

            // Calculate max time offset (how far we can slide the 20-window view)
            // With overlapping windows (step=1), we can slide until last window hits end
            maxTimeOffset = Math.max(0, entityData.length - WINDOW_SIZE - NUM_WINDOWS + 1);

            document.getElementById('timeline').max = maxTimeOffset;
            document.getElementById('info').textContent = `Time 0 / ${maxTimeOffset} (${entityData.length} points)`;

            return entityData;
        }

        function computeMetrics(entityData, windowStart) {
            // Compute all metrics for a single window
            const windowData = entityData.slice(windowStart, windowStart + WINDOW_SIZE);
            if (windowData.length < WINDOW_SIZE) return null;

            const positions = windowData.map(d => d.position);

            // Mean
            const mean = [0, 0, 0];
            positions.forEach(p => { mean[0] += p[0]; mean[1] += p[1]; mean[2] += p[2]; });
            mean[0] /= positions.length; mean[1] /= positions.length; mean[2] /= positions.length;

            // Variance
            let variance = 0;
            positions.forEach(p => {
                variance += (p[0]-mean[0])**2 + (p[1]-mean[1])**2 + (p[2]-mean[2])**2;
            });
            variance = Math.sqrt(variance / positions.length);

            // Curvature (2nd derivative)
            let curvature = 0;
            for (let i = 1; i < positions.length - 1; i++) {
                const prev = positions[i-1], curr = positions[i], next = positions[i+1];
                curvature += Math.sqrt(
                    (next[0] - 2*curr[0] + prev[0])**2 +
                    (next[1] - 2*curr[1] + prev[1])**2 +
                    (next[2] - 2*curr[2] + prev[2])**2
                );
            }
            curvature /= (positions.length - 2);

            // Velocity (path length)
            let velocity = 0;
            for (let i = 1; i < positions.length; i++) {
                const prev = positions[i-1], curr = positions[i];
                velocity += Math.sqrt(
                    (curr[0]-prev[0])**2 + (curr[1]-prev[1])**2 + (curr[2]-prev[2])**2
                );
            }

            // Acceleration (change in velocity)
            let acceleration = 0;
            for (let i = 2; i < positions.length; i++) {
                const p0 = positions[i-2], p1 = positions[i-1], p2 = positions[i];
                const v1 = Math.sqrt((p1[0]-p0[0])**2 + (p1[1]-p0[1])**2 + (p1[2]-p0[2])**2);
                const v2 = Math.sqrt((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2 + (p2[2]-p1[2])**2);
                acceleration += Math.abs(v2 - v1);
            }
            acceleration /= (positions.length - 2);

            // Coherence (from data)
            const coherence = windowData.reduce((sum, d) => sum + (d.coherence || 0.5), 0) / windowData.length;

            // Entropy (spread of values)
            let entropy = 0;
            positions.forEach(p => {
                const dist = Math.sqrt(p[0]**2 + p[1]**2 + p[2]**2);
                if (dist > 0) entropy -= dist * Math.log(dist + 0.01);
            });
            entropy = Math.abs(entropy / positions.length);

            return { variance, curvature, velocity, coherence, acceleration, entropy, mean };
        }

        function initThreeJS() {
            const canvas = document.getElementById('canvas');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x08080c);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / (window.innerHeight - 50), 0.1, 1000);
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 50);

            // Grid and axes hidden for cleaner view

            // Mouse controls
            let isDragging = false, prevX = 0, prevY = 0;
            canvas.onmousedown = (e) => { isDragging = true; prevX = e.clientX; prevY = e.clientY; };
            canvas.onmouseup = () => isDragging = false;
            canvas.onmouseleave = () => isDragging = false;
            canvas.onmousemove = (e) => {
                if (!isDragging) return;
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta -= (e.clientX - prevX) * 0.01;
                spherical.phi -= (e.clientY - prevY) * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                prevX = e.clientX; prevY = e.clientY;
            };
            canvas.onwheel = (e) => {
                e.preventDefault();
                camera.position.multiplyScalar(e.deltaY > 0 ? 1.05 : 0.95);
            };

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / (window.innerHeight - 50);
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight - 50);
            });
        }

        function plotAllMetrics(data, offset = 0) {
            // Clear existing points
            Object.values(metricPoints).forEach(group => {
                scene.remove(group);
            });
            metricPoints = {};

            // Compute metrics for 20 consecutive windows starting at offset
            // Each window overlaps: window 0 = points offset to offset+7
            //                       window 1 = points offset+1 to offset+8, etc.
            const allWindowMetrics = [];

            for (let w = 0; w < NUM_WINDOWS; w++) {
                const windowStart = offset + w;  // Step by 1 for smooth animation
                if (windowStart + WINDOW_SIZE > data.length) break;
                const metrics = computeMetrics(data, windowStart);
                if (metrics) {
                    allWindowMetrics.push({ windowIdx: w, ...metrics });
                }
            }

            if (allWindowMetrics.length === 0) return;

            // Smooth metrics with exponential moving average
            const metricNames = ['variance', 'curvature', 'velocity', 'coherence', 'acceleration', 'entropy'];

            function emaSmooth(vals, alpha) {
                const result = [vals[0]];
                for (let i = 1; i < vals.length; i++) {
                    result.push(alpha * vals[i] + (1 - alpha) * result[i - 1]);
                }
                // Also smooth backward for symmetry
                const backward = [vals[vals.length - 1]];
                for (let i = vals.length - 2; i >= 0; i--) {
                    backward.unshift(alpha * vals[i] + (1 - alpha) * backward[0]);
                }
                // Average forward and backward
                return result.map((v, i) => (v + backward[i]) / 2);
            }

            // Smooth each metric (heavier smoothing for noisy derivatives)
            metricNames.forEach(name => {
                const vals = allWindowMetrics.map(m => m[name]);
                // Curvature and acceleration are derivatives - need more smoothing (lower alpha)
                const alpha = (name === 'curvature' || name === 'acceleration' || name === 'entropy') ? 0.3 : 0.5;
                const smoothed = emaSmooth(vals, alpha);
                allWindowMetrics.forEach((wm, i) => wm[name] = smoothed[i]);
            });

            // Normalize using z-score (stdev-based)
            const meanVals = {};
            const stdVals = {};

            metricNames.forEach(name => {
                const vals = allWindowMetrics.map(m => m[name]);
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                const variance = vals.reduce((sum, v) => sum + (v - mean) ** 2, 0) / vals.length;
                const std = Math.sqrt(variance) || 1;
                meanVals[name] = mean;
                stdVals[name] = std;
            });

            // Build 2D grid of points: [windowIdx][metricIdx] = Vector3
            const pointGrid = [];
            const numMetrics = metricNames.length;

            allWindowMetrics.forEach((wm, windowIdx) => {
                const row = [];
                metricNames.forEach((metricName, metricIdx) => {
                    const zOffset = (metricIdx - 2.5) * 2;
                    const x = (wm.windowIdx / NUM_WINDOWS) * 16 - 8;
                    // Z-score normalization: (value - mean) / std, then scale to ~0-8 range
                    // z-score of ±2 std maps to 0-8 (centered at 4)
                    const zScore = (wm[metricName] - meanVals[metricName]) / stdVals[metricName];
                    const y = Math.max(0, Math.min(8, zScore * 2 + 4));  // Clamp to 0-8
                    const z = zOffset;
                    row.push({
                        pos: new THREE.Vector3(x, y, z),
                        color: METRICS[metricName].color,
                        metricName
                    });
                });
                pointGrid.push(row);
            });

            const mainGroup = new THREE.Group();

            // Helper: create curved line between two points
            function createCurvedConnection(p1, p2, color, opacity = 0.3) {
                // Create midpoint with slight curve offset
                const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                // Add perpendicular offset for curve
                const dir = new THREE.Vector3().subVectors(p2, p1);
                const perpOffset = Math.min(dir.length() * 0.15, 0.5);
                mid.y += perpOffset;

                const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
                const curvePoints = curve.getPoints(12);
                const lineGeom = new THREE.BufferGeometry().setFromPoints(curvePoints);
                const lineMat = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: opacity
                });
                return new THREE.Line(lineGeom, lineMat);
            }

            // Create shaded surface mesh between grid points
            const numWindows = pointGrid.length;
            const vertices = [];
            const indices = [];
            const colors = [];

            // Flatten grid to vertex array and create faces
            for (let w = 0; w < numWindows; w++) {
                for (let m = 0; m < numMetrics; m++) {
                    const pt = pointGrid[w][m];
                    vertices.push(pt.pos.x, pt.pos.y, pt.pos.z);

                    // Get color components (normalized 0-1)
                    const color = new THREE.Color(pt.color);
                    colors.push(color.r, color.g, color.b);
                }
            }

            // Create triangular faces for each cell in the grid
            for (let w = 0; w < numWindows - 1; w++) {
                for (let m = 0; m < numMetrics - 1; m++) {
                    // Vertex indices for this cell
                    const topLeft = w * numMetrics + m;
                    const topRight = w * numMetrics + (m + 1);
                    const bottomLeft = (w + 1) * numMetrics + m;
                    const bottomRight = (w + 1) * numMetrics + (m + 1);

                    // Two triangles per cell
                    indices.push(topLeft, bottomLeft, topRight);
                    indices.push(topRight, bottomLeft, bottomRight);
                }
            }

            // Create buffer geometry for the surface
            const surfaceGeom = new THREE.BufferGeometry();
            surfaceGeom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            surfaceGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            surfaceGeom.setIndex(indices);
            surfaceGeom.computeVertexNormals();

            // Semi-transparent material with vertex colors
            const surfaceMat = new THREE.MeshBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide
            });

            const surfaceMesh = new THREE.Mesh(surfaceGeom, surfaceMat);
            mainGroup.add(surfaceMesh);

            // Plot all dots (much smaller)
            const sphereGeom = new THREE.SphereGeometry(0.025, 6, 6);
            pointGrid.forEach(row => {
                row.forEach(pt => {
                    const sphereMat = new THREE.MeshBasicMaterial({ color: pt.color });
                    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                    sphere.position.copy(pt.pos);
                    mainGroup.add(sphere);
                });
            });

            // Create spider web connections

            for (let w = 0; w < numWindows; w++) {
                for (let m = 0; m < numMetrics; m++) {
                    const currentPt = pointGrid[w][m];

                    // Connect to next window (same metric) - horizontal web lines
                    if (w < numWindows - 1) {
                        const nextWindowPt = pointGrid[w + 1][m];
                        const line = createCurvedConnection(
                            currentPt.pos, nextWindowPt.pos,
                            currentPt.color, 0.8
                        );
                        mainGroup.add(line);
                    }

                    // Connect to adjacent metrics (same window) - vertical web lines
                    if (m < numMetrics - 1) {
                        const nextMetricPt = pointGrid[w][m + 1];
                        const line = createCurvedConnection(
                            currentPt.pos, nextMetricPt.pos,
                            0xaabbcc, 0.6
                        );
                        mainGroup.add(line);
                    }

                    // Connect diagonal down-right
                    if (w < numWindows - 1 && m < numMetrics - 1) {
                        const diagPt = pointGrid[w + 1][m + 1];
                        const line = createCurvedConnection(
                            currentPt.pos, diagPt.pos,
                            0x8899aa, 0.4
                        );
                        mainGroup.add(line);
                    }

                    // Connect diagonal down-left (reverse diagonal for full mesh)
                    if (w < numWindows - 1 && m > 0) {
                        const diagPt = pointGrid[w + 1][m - 1];
                        const line = createCurvedConnection(
                            currentPt.pos, diagPt.pos,
                            0x8899aa, 0.4
                        );
                        mainGroup.add(line);
                    }
                }
            }

            // Connect exterior boundary with brighter lines
            // Top edge (m=0)
            for (let w = 0; w < numWindows - 1; w++) {
                const line = createCurvedConnection(
                    pointGrid[w][0].pos, pointGrid[w + 1][0].pos,
                    0xeeeeff, 1.0
                );
                mainGroup.add(line);
            }

            // Bottom edge (m=numMetrics-1)
            for (let w = 0; w < numWindows - 1; w++) {
                const line = createCurvedConnection(
                    pointGrid[w][numMetrics - 1].pos, pointGrid[w + 1][numMetrics - 1].pos,
                    0xeeeeff, 1.0
                );
                mainGroup.add(line);
            }

            // Left edge (w=0)
            for (let m = 0; m < numMetrics - 1; m++) {
                const line = createCurvedConnection(
                    pointGrid[0][m].pos, pointGrid[0][m + 1].pos,
                    0xeeeeff, 1.0
                );
                mainGroup.add(line);
            }

            // Right edge (w=numWindows-1)
            for (let m = 0; m < numMetrics - 1; m++) {
                const line = createCurvedConnection(
                    pointGrid[numWindows - 1][m].pos, pointGrid[numWindows - 1][m + 1].pos,
                    0xeeeeff, 1.0
                );
                mainGroup.add(line);
            }

            scene.add(mainGroup);
            metricPoints['manifold'] = mainGroup;
        }

        function updateTimeDisplay() {
            document.getElementById('info').textContent = `Time ${timeOffset} / ${maxTimeOffset}`;
            document.getElementById('timeline').value = timeOffset;
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (isPlaying && currentTime - lastFrameTime > FRAME_DELAY) {
                lastFrameTime = currentTime;

                // Advance time by 1 window
                timeOffset++;
                if (timeOffset > maxTimeOffset) {
                    timeOffset = 0;  // Loop back to start
                }

                // Rebuild manifold at new time position
                plotAllMetrics(entityData, timeOffset);
                updateTimeDisplay();
            }

            renderer.render(scene, camera);
        }

        function setupControls() {
            document.getElementById('playBtn').onclick = () => {
                isPlaying = !isPlaying;
                document.getElementById('playBtn').textContent = isPlaying ? '❚❚' : '▶';
                document.getElementById('playBtn').classList.toggle('active', isPlaying);
            };

            document.getElementById('timeline').oninput = (e) => {
                timeOffset = parseInt(e.target.value);
                plotAllMetrics(entityData, timeOffset);
                updateTimeDisplay();
            };
        }

        async function init() {
            await loadData();
            initThreeJS();
            setupControls();
            plotAllMetrics(entityData, 0);
            animate(0);
        }

        init();
    </script>
</body>
</html>

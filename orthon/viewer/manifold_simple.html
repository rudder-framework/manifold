<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORTHON Phase Space Manifold</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: rgba(255,255,255,0.9);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .manifold-panel {
            flex: 6;
            position: relative;
        }
        #canvas {
            width: 100%;
            height: 100%;
        }
        .slice-panel {
            flex: 4;
            background: rgba(15,15,25,0.9);
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
        }
        .slice-header {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .slice-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255,255,255,0.8);
        }
        #slice-canvas {
            flex: 1;
            margin: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        .controls {
            padding: 16px 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.7);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: rgba(255,255,255,0.1); }
        button.active { background: #3182ce; border-color: #3182ce; }
        input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3182ce;
            border-radius: 50%;
            cursor: pointer;
        }
        .time-display {
            font-family: monospace;
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            min-width: 60px;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 16px;
            padding: 12px 16px;
            background: rgba(15,15,25,0.9);
            border-radius: 8px;
            font-size: 11px;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .regime-ribbon {
            display: flex;
            height: 24px;
            margin-top: 12px;
            border-radius: 4px;
            overflow: hidden;
        }
        .regime-seg {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
        }
        .regime-seg.stable { background: #1a365d; color: #3182ce; }
        .regime-seg.transitional { background: #744210; color: #d69e2e; }
        .regime-seg.critical { background: #742a2a; color: #e53e3e; }
        .regime-seg.current { transform: scaleY(1.3); }
    </style>
</head>
<body>
    <div class="container">
        <div class="manifold-panel">
            <canvas id="canvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background:#3182ce;box-shadow:0 0 8px #3182ce"></div>
                    <span>Stable</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#d69e2e;box-shadow:0 0 8px #d69e2e"></div>
                    <span>Transitional</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#e53e3e;box-shadow:0 0 8px #e53e3e"></div>
                    <span>Critical</span>
                </div>
            </div>
        </div>
        <div class="slice-panel">
            <div class="slice-header">
                <h2>SIGNAL BEHAVIOR</h2>
            </div>
            <canvas id="slice-canvas"></canvas>
            <div class="controls">
                <button id="playBtn">▶ Play</button>
                <input type="range" id="timeline" min="0" max="499" value="0">
                <span class="time-display" id="timeDisplay">t = 0</span>
            </div>
            <div class="controls">
                <div class="regime-ribbon" id="regimeRibbon"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================================
        // ORTHON Phase Space Manifold Viewer (Simplified)
        // ============================================================

        let scene, camera, renderer, controls;
        let trajectoryLine, signalMeshes = [];
        let manifoldData, currentTime = 0, isPlaying = false;
        let sliceCtx;

        // Load real data from JSON or fallback to generated data
        async function loadData() {
            try {
                const response = await fetch('data/manifold.json');
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();

                console.log(`Loaded: ${data.trajectory.length} points from ${data.metadata?.source || 'unknown'}`);

                // Transform signals from object format to array format
                const signalArray = Object.entries(data.signals || {}).map(([id, sig], idx) => ({
                    id: id,
                    role: sig.role || 'CONDUIT',
                    color: sig.role === 'SOURCE' ? 0xff6b6b : sig.role === 'SINK' ? 0x4ecdc4 : 0xa0aec0,
                    trajectory: sig.trajectory || []
                }));

                return {
                    trajectory: data.trajectory,
                    signals: signalArray,
                    metadata: data.metadata,
                    basins: data.basins || []
                };
            } catch (e) {
                console.warn('Loading JSON failed, using generated data:', e);
                return generateFallbackData();
            }
        }

        // Fallback Lorenz attractor data
        function generateFallbackData() {
            const trajectory = [];
            const sigma = 10, rho = 28, beta = 8/3;
            let x = 1, y = 1, z = 1;
            const dt = 0.01, scale = 0.15;

            for (let i = 0; i < 500; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;
                x += dx * dt;
                y += dy * dt;
                z += dz * dt;

                let regime = 'stable';
                if (z > 30) regime = 'transitional';
                if (Math.abs(x) > 15 && z > 35) regime = 'critical';

                trajectory.push({
                    t: i,
                    position: [x * scale, (z - 25) * scale, y * scale],
                    regime: regime,
                    coherence: regime === 'critical' ? 0.3 : regime === 'transitional' ? 0.6 : 0.85
                });
            }

            const signals = ['PS1', 'FS1', 'FS2', 'TS1'].map((id, idx) => ({
                id: id,
                role: idx === 0 ? 'SOURCE' : idx < 3 ? 'SINK' : 'CONDUIT',
                color: idx === 0 ? 0xff6b6b : idx < 3 ? 0x4ecdc4 : 0xa0aec0,
                trajectory: trajectory.map((t, i) => [
                    t.position[0] + Math.sin(i * 0.1 + idx) * 0.3,
                    t.position[1] + Math.cos(i * 0.12 + idx) * 0.25,
                    t.position[2] + Math.sin(i * 0.11 + idx) * 0.28
                ])
            }));

            return { trajectory, signals };
        }

        async function init() {
            manifoldData = await loadData();

            // Update title with source
            if (manifoldData.metadata?.source) {
                document.title = `ORTHON: ${manifoldData.metadata.source}`;
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.FogExp2(0x0a0a1a, 0.06);

            // Camera
            const container = document.getElementById('canvas').parentElement;
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Lights
            scene.add(new THREE.AmbientLight(0x404060, 0.5));
            const light1 = new THREE.DirectionalLight(0xaaccff, 0.8);
            light1.position.set(5, 10, 5);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xffaa66, 0.4);
            light2.position.set(-5, -3, -5);
            scene.add(light2);

            // Grid
            const grid = new THREE.GridHelper(20, 40, 0x1a1a2e, 0x0f0f1a);
            grid.position.y = -3;
            scene.add(grid);

            // Build trajectory
            buildTrajectory();

            // Build signals
            buildSignals();

            // Build regime ribbon
            buildRegimeRibbon();

            // Slice canvas
            const sliceCanvas = document.getElementById('slice-canvas');
            sliceCanvas.width = sliceCanvas.clientWidth;
            sliceCanvas.height = sliceCanvas.clientHeight;
            sliceCtx = sliceCanvas.getContext('2d');

            // Controls
            setupControls();

            // Resize
            window.addEventListener('resize', onResize);

            // Start
            animate();
        }

        function buildTrajectory() {
            const points = manifoldData.trajectory.map(t => new THREE.Vector3(...t.position));

            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // Light grey manifold
            const material = new THREE.LineBasicMaterial({
                color: 0xaaaaaa,
                linewidth: 2
            });

            trajectoryLine = new THREE.Line(geometry, material);
            scene.add(trajectoryLine);

            // Add small dots at intervals
            const dotGeom = new THREE.SphereGeometry(0.03, 6, 6);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
            for (let i = 0; i < points.length; i += 50) {
                const dot = new THREE.Mesh(dotGeom, dotMat);
                dot.position.copy(points[i]);
                scene.add(dot);
            }
        }

        function buildSignals() {
            const geometry = new THREE.SphereGeometry(0.04, 8, 8);

            manifoldData.signals.forEach(signal => {
                const material = new THREE.MeshBasicMaterial({
                    color: signal.color
                });

                const mesh = new THREE.Mesh(geometry, material);
                if (signal.trajectory && signal.trajectory.length > 0) {
                    mesh.position.set(...signal.trajectory[0]);
                }
                mesh.userData = signal;
                signalMeshes.push(mesh);
                scene.add(mesh);
            });
        }

        function buildRegimeRibbon() {
            const ribbon = document.getElementById('regimeRibbon');
            const step = Math.ceil(manifoldData.trajectory.length / 20);

            for (let i = 0; i < manifoldData.trajectory.length; i += step) {
                const seg = document.createElement('div');
                seg.className = `regime-seg ${manifoldData.trajectory[i].regime}`;
                seg.dataset.idx = i;
                seg.onclick = () => goToTime(i);
                ribbon.appendChild(seg);
            }
        }

        function setupControls() {
            // Set timeline max based on data length
            const maxTime = manifoldData.trajectory.length - 1;
            document.getElementById('timeline').max = maxTime;

            // Play button
            document.getElementById('playBtn').onclick = () => {
                isPlaying = !isPlaying;
                document.getElementById('playBtn').textContent = isPlaying ? '❚❚ Pause' : '▶ Play';
                document.getElementById('playBtn').classList.toggle('active', isPlaying);
            };

            // Timeline
            document.getElementById('timeline').oninput = (e) => goToTime(parseInt(e.target.value));

            // Mouse drag rotation
            let isDragging = false, prevX = 0, prevY = 0;
            const canvas = document.getElementById('canvas');

            canvas.onmousedown = (e) => { isDragging = true; prevX = e.clientX; prevY = e.clientY; };
            canvas.onmouseup = () => isDragging = false;
            canvas.onmouseleave = () => isDragging = false;
            canvas.onmousemove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - prevX;
                const dy = e.clientY - prevY;

                // Rotate camera around origin
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta -= dx * 0.005;
                spherical.phi -= dy * 0.005;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);

                prevX = e.clientX;
                prevY = e.clientY;
            };

            // Zoom
            canvas.onwheel = (e) => {
                e.preventDefault();
                camera.position.multiplyScalar(e.deltaY > 0 ? 1.1 : 0.9);
            };
        }

        function goToTime(t) {
            currentTime = t;
            document.getElementById('timeline').value = t;
            document.getElementById('timeDisplay').textContent = `t = ${t}`;

            // Update signals
            signalMeshes.forEach(mesh => {
                const pos = mesh.userData.trajectory[t];
                if (pos) mesh.position.set(...pos);
            });

            // Update regime ribbon
            const step = Math.ceil(manifoldData.trajectory.length / 20);
            document.querySelectorAll('.regime-seg').forEach((seg, i) => {
                const segTime = i * step;
                seg.classList.toggle('current', t >= segTime && t < segTime + step);
            });

            // Update slice
            renderSlice();
        }

        function renderSlice() {
            if (!sliceCtx) return;
            const w = sliceCtx.canvas.width;
            const h = sliceCtx.canvas.height;
            const t = Math.floor(currentTime);
            const point = manifoldData.trajectory[t];

            // Clear
            sliceCtx.fillStyle = '#0a0a14';
            sliceCtx.fillRect(0, 0, w, h);

            // Grid
            // Compute signal positions and cluster them
            const signals = manifoldData.signals;
            const numSignals = signals.length;
            const rowHeight = (h - 60) / numSignals;
            const leftMargin = 100;
            const barWidth = w - leftMargin - 40;

            // Get current positions for each signal
            const currentPositions = signals.map(s => {
                const pos = s.trajectory[t] || [0, 0, 0];
                return { signal: s, pos, magnitude: Math.sqrt(pos[0]**2 + pos[1]**2 + pos[2]**2) };
            });

            // Simple clustering: compute mean position, group by distance
            const meanPos = [0, 0, 0];
            currentPositions.forEach(cp => {
                meanPos[0] += cp.pos[0] / numSignals;
                meanPos[1] += cp.pos[1] / numSignals;
                meanPos[2] += cp.pos[2] / numSignals;
            });

            // Assign clusters based on distance from mean
            const clusterColors = ['#3182ce', '#48bb78', '#d69e2e', '#e53e3e'];
            currentPositions.forEach(cp => {
                const dist = Math.sqrt(
                    (cp.pos[0] - meanPos[0])**2 +
                    (cp.pos[1] - meanPos[1])**2 +
                    (cp.pos[2] - meanPos[2])**2
                );
                cp.deviation = dist;
                cp.cluster = dist < 0.5 ? 0 : dist < 1.0 ? 1 : dist < 1.5 ? 2 : 3;
            });

            // Find max deviation for scaling
            const maxDev = Math.max(...currentPositions.map(cp => cp.deviation), 0.1);

            // Draw each signal row
            currentPositions.forEach((cp, i) => {
                const y = 40 + i * rowHeight + rowHeight / 2;
                const color = clusterColors[cp.cluster];

                // Signal name
                sliceCtx.fillStyle = 'rgba(255,255,255,0.6)';
                sliceCtx.font = '10px monospace';
                sliceCtx.textAlign = 'right';
                const shortName = cp.signal.id.replace('temp_', 'T_').replace('press_', 'P_').replace('speed_', 'S_');
                sliceCtx.fillText(shortName, leftMargin - 10, y + 4);

                // Background bar track
                sliceCtx.fillStyle = 'rgba(255,255,255,0.05)';
                sliceCtx.fillRect(leftMargin, y - 6, barWidth, 12);

                // Center line (mean)
                sliceCtx.strokeStyle = 'rgba(255,255,255,0.2)';
                sliceCtx.beginPath();
                sliceCtx.moveTo(leftMargin + barWidth / 2, y - 8);
                sliceCtx.lineTo(leftMargin + barWidth / 2, y + 8);
                sliceCtx.stroke();

                // Deviation bar
                const barX = leftMargin + barWidth / 2;
                const deviationWidth = (cp.deviation / maxDev) * (barWidth / 2) * 0.9;
                const direction = cp.pos[0] > meanPos[0] ? 1 : -1;

                sliceCtx.fillStyle = color + '60';
                sliceCtx.fillRect(barX, y - 4, direction * deviationWidth, 8);

                // Dot at end
                sliceCtx.fillStyle = color;
                sliceCtx.beginPath();
                sliceCtx.arc(barX + direction * deviationWidth, y, 4, 0, Math.PI * 2);
                sliceCtx.fill();

                // Cluster indicator
                sliceCtx.fillStyle = color;
                sliceCtx.beginPath();
                sliceCtx.arc(leftMargin - 25, y, 3, 0, Math.PI * 2);
                sliceCtx.fill();
            });

            // Legend for clusters
            sliceCtx.fillStyle = 'rgba(255,255,255,0.4)';
            sliceCtx.font = '9px sans-serif';
            sliceCtx.textAlign = 'left';
            sliceCtx.fillText('← cohesive', leftMargin, h - 15);
            sliceCtx.textAlign = 'right';
            sliceCtx.fillText('divergent →', w - 20, h - 15);
            sliceCtx.textAlign = 'center';
            sliceCtx.fillText('cluster mean', leftMargin + barWidth / 2, h - 15);

            // Current regime/coherence
            sliceCtx.fillStyle = 'rgba(255,255,255,0.5)';
            sliceCtx.font = '11px monospace';
            sliceCtx.textAlign = 'left';
            sliceCtx.fillText(`t=${t}  ${point.regime}  coherence:${point.coherence.toFixed(2)}`, 10, 20);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                currentTime = (currentTime + 0.5) % manifoldData.trajectory.length;
                goToTime(Math.floor(currentTime));
            }

            // Slow auto-rotate when not playing
            if (!isPlaying) {
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta += 0.001;
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        function onResize() {
            const container = document.getElementById('canvas').parentElement;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);

            const sc = document.getElementById('slice-canvas');
            sc.width = sc.clientWidth;
            sc.height = sc.clientHeight;
            renderSlice();
        }

        // Start async
        init().catch(e => console.error('Init failed:', e));
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORTHON Phase Space Manifold</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Regime Colors */
            --stable: #3182ce;
            --stable-dark: #1a365d;
            --transitional: #d69e2e;
            --transitional-dark: #744210;
            --critical: #e53e3e;
            --critical-dark: #742a2a;
            --recovery: #48bb78;
            --recovery-dark: #22543d;

            /* Signal Roles */
            --source: #ff6b6b;
            --sink: #4ecdc4;
            --conduit: #a0aec0;
            --isolated: #4a5568;

            /* UI */
            --bg-dark: #0a0a0f;
            --bg-panel: rgba(15, 15, 25, 0.85);
            --text-primary: rgba(255, 255, 255, 0.9);
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            background: var(--bg-dark);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 24px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            z-index: 100;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .header-actions {
            display: flex;
            gap: 16px;
        }

        .header-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* 3D Manifold Panel */
        .manifold-panel {
            flex: 6;
            position: relative;
            background: var(--bg-dark);
        }

        #manifold-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 2D Slice Panel */
        .slice-panel {
            flex: 4;
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border);
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
        }

        .slice-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .slice-header h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .slice-modes {
            display: flex;
            gap: 8px;
        }

        .slice-mode-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .slice-mode-btn.active {
            background: rgba(49, 130, 206, 0.2);
            border-color: var(--stable);
            color: var(--stable);
        }

        .slice-canvas-container {
            flex: 1;
            position: relative;
            padding: 20px;
        }

        #slice-canvas {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .slice-info {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            font-size: 12px;
        }

        .slice-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .slice-info-label {
            color: var(--text-tertiary);
        }

        .slice-info-value {
            color: var(--text-primary);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        /* Timeline Controls */
        .timeline-panel {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 12px;
        }

        .playback-btns {
            display: flex;
            gap: 4px;
        }

        .playback-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .playback-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .playback-btn.active {
            background: var(--stable);
            border-color: var(--stable);
            color: white;
        }

        .timeline-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
            cursor: pointer;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--stable);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(49, 130, 206, 0.5);
        }

        .time-display {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 80px;
        }

        .speed-select {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        /* Regime Ribbon */
        .regime-ribbon {
            display: flex;
            height: 24px;
            border-radius: 4px;
            overflow: hidden;
        }

        .regime-segment {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }

        .regime-segment.stable { background: var(--stable-dark); color: var(--stable); }
        .regime-segment.transitional { background: var(--transitional-dark); color: var(--transitional); }
        .regime-segment.critical { background: var(--critical-dark); color: var(--critical); }
        .regime-segment.recovery { background: var(--recovery-dark); color: var(--recovery); }

        .regime-segment.current {
            transform: scaleY(1.2);
            box-shadow: 0 0 20px currentColor;
        }

        /* Signal Legend */
        .signal-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 16px;
            padding: 12px 16px;
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.source { background: var(--source); box-shadow: 0 0 8px var(--source); }
        .legend-dot.sink { background: var(--sink); box-shadow: 0 0 8px var(--sink); }
        .legend-dot.conduit { background: var(--conduit); }
        .legend-dot.isolated { background: var(--isolated); }

        /* Info Panels */
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            transform: translateX(320px);
            transition: transform 0.3s ease-out;
            z-index: 50;
        }

        .info-panel.visible {
            transform: translateX(0);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
        }

        .info-panel-close {
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
        }

        .info-panel-content {
            padding: 16px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .info-label {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .info-value {
            font-size: 13px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .info-divider {
            height: 1px;
            background: var(--border);
            margin: 16px 0;
        }

        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            flex: 1;
            margin-left: 12px;
        }

        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .progress-fill.stable { background: var(--stable); }
        .progress-fill.warning { background: var(--transitional); }
        .progress-fill.critical { background: var(--critical); }

        /* Role badge */
        .role-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .role-badge.source { background: rgba(255, 107, 107, 0.2); color: var(--source); }
        .role-badge.sink { background: rgba(78, 205, 196, 0.2); color: var(--sink); }
        .role-badge.conduit { background: rgba(160, 174, 192, 0.2); color: var(--conduit); }

        .role-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .role-indicator.source { background: var(--source); }
        .role-indicator.sink { background: var(--sink); }
        .role-indicator.conduit { background: var(--conduit); }

        /* View Detail Button */
        .view-detail-btn {
            width: 100%;
            padding: 10px;
            background: rgba(49, 130, 206, 0.1);
            border: 1px solid var(--stable);
            color: var(--stable);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .view-detail-btn:hover {
            background: rgba(49, 130, 206, 0.2);
        }

        /* Loading State */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border);
            border-top-color: var(--stable);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Regime indicator on trajectory */
        .regime-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .regime-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .regime-dot.stable { background: var(--stable); box-shadow: 0 0 8px var(--stable); }
        .regime-dot.transitional { background: var(--transitional); box-shadow: 0 0 8px var(--transitional); }
        .regime-dot.critical { background: var(--critical); box-shadow: 0 0 8px var(--critical); }
        .regime-dot.recovery { background: var(--recovery); box-shadow: 0 0 8px var(--recovery); }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Phase Space...</div>
    </div>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1>ORTHON Phase Space Manifold</h1>
            <div class="header-actions">
                <button class="header-btn" id="settings-btn">Settings</button>
                <button class="header-btn" id="export-btn">Export</button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- 3D Manifold Panel -->
            <div class="manifold-panel">
                <canvas id="manifold-canvas"></canvas>

                <!-- Signal Legend -->
                <div class="signal-legend">
                    <div class="legend-item">
                        <div class="legend-dot source"></div>
                        <span>SOURCE</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot sink"></div>
                        <span>SINK</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot conduit"></div>
                        <span>CONDUIT</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot isolated"></div>
                        <span>ISOLATED</span>
                    </div>
                </div>

                <!-- Info Panel (slides in on click) -->
                <div class="info-panel" id="info-panel">
                    <div class="info-panel-header">
                        <div class="info-panel-title">
                            <span id="panel-icon"></span>
                            <span id="panel-title">Signal: PS1</span>
                        </div>
                        <button class="info-panel-close" id="panel-close">&times;</button>
                    </div>
                    <div class="info-panel-content" id="panel-content">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>

            <!-- 2D Slice Panel -->
            <div class="slice-panel">
                <div class="slice-header">
                    <h2>INTERIOR SLICE</h2>
                    <div class="slice-modes">
                        <button class="slice-mode-btn active" data-mode="spatial">Spatial</button>
                        <button class="slice-mode-btn" data-mode="temporal">Temporal</button>
                        <button class="slice-mode-btn" data-mode="rolling">Rolling</button>
                    </div>
                </div>
                <div class="slice-canvas-container">
                    <canvas id="slice-canvas"></canvas>
                </div>
                <div class="slice-info">
                    <div class="slice-info-row">
                        <span class="slice-info-label">Slice Position</span>
                        <span class="slice-info-value" id="slice-position">Z = 0.00</span>
                    </div>
                    <div class="slice-info-row">
                        <span class="slice-info-label">Signals in View</span>
                        <span class="slice-info-value" id="slice-signals">0</span>
                    </div>
                    <div class="slice-info-row">
                        <span class="slice-info-label">Local Density</span>
                        <span class="slice-info-value" id="slice-density">--</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Panel -->
        <div class="timeline-panel">
            <div class="timeline-controls">
                <div class="playback-btns">
                    <button class="playback-btn" id="btn-start" title="Start">|&#9664;</button>
                    <button class="playback-btn" id="btn-back" title="Step Back">&#9664;</button>
                    <button class="playback-btn" id="btn-play" title="Play/Pause">&#9654;</button>
                    <button class="playback-btn" id="btn-forward" title="Step Forward">&#9654;</button>
                    <button class="playback-btn" id="btn-end" title="End">&#9654;|</button>
                </div>
                <input type="range" class="timeline-slider" id="timeline" min="0" max="100" value="0">
                <span class="time-display" id="time-display">t = 0</span>
                <select class="speed-select" id="speed-select">
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="5">5x</option>
                    <option value="10">10x</option>
                </select>
            </div>
            <div class="regime-ribbon" id="regime-ribbon">
                <!-- Dynamic regime segments -->
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        // ============================================================================
        // ORTHON Phase Space Manifold Viewer
        // ============================================================================

        // Color constants
        const COLORS = {
            stable: 0x3182ce,
            stableDark: 0x1a365d,
            transitional: 0xd69e2e,
            transitionalDark: 0x744210,
            critical: 0xe53e3e,
            criticalDark: 0x742a2a,
            recovery: 0x48bb78,
            recoveryDark: 0x22543d,
            source: 0xff6b6b,
            sink: 0x4ecdc4,
            conduit: 0xa0aec0,
            isolated: 0x4a5568,
            fog: 0x0a0a1a,
            ambient: 0x1a1a2e
        };

        // State
        let manifoldData = null;
        let currentTime = 0;
        let isPlaying = false;
        let playbackSpeed = 1;
        let animationFrame = null;
        let lastFrameTime = 0;

        // Three.js objects
        let scene, camera, renderer, controls, composer;
        let trajectoryLine, trajectoryPoints = [];
        let signalMeshes = {};
        let basinMeshes = [];
        let slicePlane, slicePlaneHelper;

        // 2D Slice canvas
        let sliceCtx;
        let sliceMode = 'spatial';
        let slicePosition = 0;

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        async function init() {
            // Initialize 3D scene
            initThreeJS();

            // Initialize 2D slice canvas
            initSliceCanvas();

            // Load data
            await loadManifoldData();

            // Setup interactions
            setupControls();
            setupInfoPanel();

            // Start render loop
            animate();

            // Hide loading
            document.getElementById('loading').classList.add('hidden');
        }

        function initThreeJS() {
            const canvas = document.getElementById('manifold-canvas');
            const container = canvas.parentElement;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.fog);
            scene.fog = new THREE.FogExp2(COLORS.fog, 0.08);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // Orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Lights
            setupLighting();

            // Post-processing (bloom)
            setupPostProcessing();

            // Grid helper (subtle)
            const gridHelper = new THREE.GridHelper(20, 40, 0x1a1a2e, 0x0f0f1a);
            gridHelper.position.y = -3;
            scene.add(gridHelper);

            // Resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function setupLighting() {
            // Ambient light
            const ambient = new THREE.AmbientLight(0x404060, 0.4);
            scene.add(ambient);

            // Primary light (cool blue-white from above-right)
            const primaryLight = new THREE.DirectionalLight(0xaaccff, 0.8);
            primaryLight.position.set(5, 10, 5);
            scene.add(primaryLight);

            // Accent light (warm amber from below-left)
            const accentLight = new THREE.DirectionalLight(0xffaa66, 0.4);
            accentLight.position.set(-5, -3, -5);
            scene.add(accentLight);

            // Rim light
            const rimLight = new THREE.PointLight(0x6688ff, 0.5, 20);
            rimLight.position.set(-8, 4, 0);
            scene.add(rimLight);
        }

        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);

            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8,  // strength
                0.4,  // radius
                0.85  // threshold
            );
            composer.addPass(bloomPass);
        }

        function initSliceCanvas() {
            const canvas = document.getElementById('slice-canvas');
            sliceCtx = canvas.getContext('2d');
            resizeSliceCanvas();
            window.addEventListener('resize', resizeSliceCanvas);
        }

        function resizeSliceCanvas() {
            const canvas = document.getElementById('slice-canvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            renderSlice();
        }

        // ============================================================================
        // DATA LOADING
        // ============================================================================

        async function loadManifoldData() {
            try {
                const response = await fetch('data/manifold.json');
                if (response.ok) {
                    manifoldData = await response.json();
                } else {
                    // Generate sample data if file not found
                    manifoldData = generateSampleData();
                }

                buildScene();
                buildRegimeRibbon();
                updateTimeDisplay();

            } catch (error) {
                console.log('Loading sample data:', error);
                manifoldData = generateSampleData();
                buildScene();
                buildRegimeRibbon();
                updateTimeDisplay();
            }
        }

        function generateSampleData() {
            // Generate a beautiful strange attractor trajectory
            const trajectory = [];
            const nSteps = 500;

            // Lorenz-like parameters
            const sigma = 10, rho = 28, beta = 8/3;
            let x = 1, y = 1, z = 1;
            const dt = 0.01;
            const scale = 0.15;

            for (let i = 0; i < nSteps; i++) {
                // Lorenz equations
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;

                x += dx * dt;
                y += dy * dt;
                z += dz * dt;

                // Determine regime based on position
                let regime = 'stable';
                let coherence = 0.85;

                if (z > 30) {
                    regime = 'transitional';
                    coherence = 0.65;
                }
                if (Math.abs(x) > 15 && z > 35) {
                    regime = 'critical';
                    coherence = 0.35;
                }
                if (z < 15 && Math.abs(x) < 10) {
                    regime = 'recovery';
                    coherence = 0.75;
                }

                trajectory.push({
                    t: i,
                    timestamp: new Date(2024, 0, 1 + i).toISOString(),
                    position: [x * scale, (z - 25) * scale, y * scale],
                    regime: regime,
                    coherence: coherence,
                    dominant_signals: ['PS1', 'FS2'],
                    alerts: regime === 'critical' ? ['regime_break'] : []
                });
            }

            // Generate signal trajectories
            const signals = {
                'PS1': {
                    role: 'SOURCE',
                    color: '#ff6b6b',
                    trajectory: trajectory.map((t, i) => [
                        t.position[0] + Math.sin(i * 0.1) * 0.3,
                        t.position[1] + Math.cos(i * 0.15) * 0.2,
                        t.position[2] + Math.sin(i * 0.12) * 0.25
                    ])
                },
                'FS1': {
                    role: 'SINK',
                    color: '#4ecdc4',
                    trajectory: trajectory.map((t, i) => [
                        t.position[0] + Math.cos(i * 0.08) * 0.4,
                        t.position[1] + Math.sin(i * 0.1) * 0.3,
                        t.position[2] + Math.cos(i * 0.11) * 0.35
                    ])
                },
                'FS2': {
                    role: 'SINK',
                    color: '#4ecdc4',
                    trajectory: trajectory.map((t, i) => [
                        t.position[0] - Math.sin(i * 0.09) * 0.35,
                        t.position[1] - Math.cos(i * 0.12) * 0.25,
                        t.position[2] - Math.sin(i * 0.1) * 0.3
                    ])
                },
                'TS1': {
                    role: 'CONDUIT',
                    color: '#a0aec0',
                    trajectory: trajectory.map((t, i) => [
                        t.position[0] + Math.cos(i * 0.07) * 0.25,
                        t.position[1] - Math.sin(i * 0.09) * 0.2,
                        t.position[2] + Math.cos(i * 0.08) * 0.22
                    ])
                }
            };

            return {
                metadata: {
                    n_signals: 4,
                    n_timesteps: nSteps,
                    n_engines: 41,
                    time_range: ['2024-01-01', '2024-06-30']
                },
                trajectory: trajectory,
                signals: signals,
                basins: [
                    {
                        id: 'basin_1',
                        centroid: [-1.5, 0.5, 0],
                        radius: 2,
                        regime: 'stable'
                    },
                    {
                        id: 'basin_2',
                        centroid: [1.5, 0.5, 0],
                        radius: 2,
                        regime: 'transitional'
                    }
                ],
                transitions: []
            };
        }

        // ============================================================================
        // SCENE BUILDING
        // ============================================================================

        function buildScene() {
            // Clear existing objects
            clearScene();

            // Build trajectory
            buildTrajectory();

            // Build signal particles
            buildSignals();

            // Build basin volumes
            buildBasins();

            // Build slice plane
            buildSlicePlane();

            // Update timeline slider
            const timeline = document.getElementById('timeline');
            timeline.max = manifoldData.trajectory.length - 1;
        }

        function clearScene() {
            // Remove trajectory
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
                trajectoryLine.geometry.dispose();
                trajectoryLine.material.dispose();
            }

            // Remove signals
            Object.values(signalMeshes).forEach(mesh => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            signalMeshes = {};

            // Remove basins
            basinMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            basinMeshes = [];
        }

        function buildTrajectory() {
            trajectoryPoints = manifoldData.trajectory.map(t => new THREE.Vector3(...t.position));

            // Create tube geometry for thick trajectory
            const curve = new THREE.CatmullRomCurve3(trajectoryPoints);
            const tubeGeometry = new THREE.TubeGeometry(curve, trajectoryPoints.length * 2, 0.05, 8, false);

            // Create gradient material based on regime
            const colors = [];
            const positions = tubeGeometry.attributes.position;

            for (let i = 0; i < positions.count; i++) {
                const t = i / positions.count;
                const idx = Math.floor(t * (manifoldData.trajectory.length - 1));
                const regime = manifoldData.trajectory[idx].regime;
                const color = new THREE.Color(COLORS[regime] || COLORS.stable);
                colors.push(color.r, color.g, color.b);
            }

            tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                emissive: 0x222244,
                emissiveIntensity: 0.3,
                metalness: 0.3,
                roughness: 0.7
            });

            trajectoryLine = new THREE.Mesh(tubeGeometry, material);
            scene.add(trajectoryLine);

            // Add glowing core line
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(trajectoryPoints);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const coreLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(coreLine);
        }

        function buildSignals() {
            const geometry = new THREE.SphereGeometry(0.15, 32, 32);

            Object.entries(manifoldData.signals).forEach(([signalId, signalData]) => {
                const color = new THREE.Color(signalData.color);

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5,
                    metalness: 0.5,
                    roughness: 0.3
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { signalId, role: signalData.role };

                // Set initial position
                if (signalData.trajectory && signalData.trajectory[0]) {
                    mesh.position.set(...signalData.trajectory[0]);
                }

                signalMeshes[signalId] = mesh;
                scene.add(mesh);
            });
        }

        function buildBasins() {
            manifoldData.basins.forEach(basin => {
                const geometry = new THREE.SphereGeometry(basin.radius, 32, 32);
                const color = new THREE.Color(COLORS[basin.regime] || COLORS.stable);

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...basin.centroid);
                mesh.userData = { basinId: basin.id };

                basinMeshes.push(mesh);
                scene.add(mesh);
            });
        }

        function buildSlicePlane() {
            // Visual slice plane
            const planeGeometry = new THREE.PlaneGeometry(10, 10);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x3182ce,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });

            slicePlane = new THREE.Mesh(planeGeometry, planeMaterial);
            slicePlane.rotation.x = Math.PI / 2;
            slicePlane.position.y = slicePosition;
            scene.add(slicePlane);

            // Slice plane border
            const borderGeometry = new THREE.EdgesGeometry(planeGeometry);
            const borderMaterial = new THREE.LineBasicMaterial({
                color: 0x3182ce,
                transparent: true,
                opacity: 0.5
            });
            slicePlaneHelper = new THREE.LineSegments(borderGeometry, borderMaterial);
            slicePlaneHelper.rotation.x = Math.PI / 2;
            slicePlaneHelper.position.y = slicePosition;
            scene.add(slicePlaneHelper);
        }

        // ============================================================================
        // REGIME RIBBON
        // ============================================================================

        function buildRegimeRibbon() {
            const ribbon = document.getElementById('regime-ribbon');
            ribbon.innerHTML = '';

            // Sample regimes (show ~20 segments)
            const step = Math.ceil(manifoldData.trajectory.length / 20);

            for (let i = 0; i < manifoldData.trajectory.length; i += step) {
                const point = manifoldData.trajectory[i];
                const segment = document.createElement('div');
                segment.className = `regime-segment ${point.regime}`;
                segment.textContent = point.regime.substring(0, 4).toUpperCase();
                segment.dataset.index = i;
                segment.addEventListener('click', () => goToTime(i));
                ribbon.appendChild(segment);
            }

            updateRegimeRibbon();
        }

        function updateRegimeRibbon() {
            const segments = document.querySelectorAll('.regime-segment');
            const step = Math.ceil(manifoldData.trajectory.length / segments.length);

            segments.forEach((segment, idx) => {
                const segmentTime = idx * step;
                segment.classList.toggle('current',
                    currentTime >= segmentTime && currentTime < segmentTime + step
                );
            });
        }

        // ============================================================================
        // ANIMATION & PLAYBACK
        // ============================================================================

        function animate(time = 0) {
            animationFrame = requestAnimationFrame(animate);

            // Update playback
            if (isPlaying) {
                const delta = (time - lastFrameTime) / 1000;
                lastFrameTime = time;

                currentTime += delta * playbackSpeed * 30;
                if (currentTime >= manifoldData.trajectory.length - 1) {
                    currentTime = 0;
                }

                updateScene();
                updateTimeDisplay();
            }

            // Update controls
            controls.update();

            // Render
            composer.render();

            // Update slice
            if (time % 3 < 1) {
                renderSlice();
            }
        }

        function updateScene() {
            const idx = Math.floor(currentTime);
            const point = manifoldData.trajectory[idx];

            if (!point) return;

            // Update signal positions
            Object.entries(manifoldData.signals).forEach(([signalId, signalData]) => {
                const mesh = signalMeshes[signalId];
                if (mesh && signalData.trajectory[idx]) {
                    mesh.position.set(...signalData.trajectory[idx]);

                    // Breathing animation
                    const breathe = 1 + Math.sin(currentTime * 0.5 + signalId.charCodeAt(2)) * 0.05;
                    mesh.scale.setScalar(breathe);
                }
            });

            // Update timeline slider
            document.getElementById('timeline').value = idx;

            // Update regime ribbon
            updateRegimeRibbon();
        }

        function updateTimeDisplay() {
            const idx = Math.floor(currentTime);
            const point = manifoldData.trajectory[idx];

            document.getElementById('time-display').textContent = `t = ${idx}`;

            // Update slice info
            if (point) {
                document.getElementById('slice-position').textContent =
                    `Z = ${slicePosition.toFixed(2)}`;
            }
        }

        function goToTime(t) {
            currentTime = t;
            updateScene();
            updateTimeDisplay();
            renderSlice();
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            lastFrameTime = performance.now();

            const btn = document.getElementById('btn-play');
            btn.classList.toggle('active', isPlaying);
            btn.innerHTML = isPlaying ? '&#10074;&#10074;' : '&#9654;';
        }

        // ============================================================================
        // 2D SLICE RENDERING
        // ============================================================================

        function renderSlice() {
            if (!sliceCtx || !manifoldData) return;

            const canvas = sliceCtx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            const idx = Math.floor(currentTime);

            // Clear
            sliceCtx.fillStyle = 'rgba(10, 10, 20, 1)';
            sliceCtx.fillRect(0, 0, width, height);

            // Draw grid
            sliceCtx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            sliceCtx.lineWidth = 1;

            const gridSize = 40;
            for (let x = 0; x <= width; x += gridSize) {
                sliceCtx.beginPath();
                sliceCtx.moveTo(x, 0);
                sliceCtx.lineTo(x, height);
                sliceCtx.stroke();
            }
            for (let y = 0; y <= height; y += gridSize) {
                sliceCtx.beginPath();
                sliceCtx.moveTo(0, y);
                sliceCtx.lineTo(width, y);
                sliceCtx.stroke();
            }

            // Map 3D to 2D (project onto XZ plane at slice Y position)
            const scale = 40;
            const centerX = width / 2;
            const centerY = height / 2;

            // Draw coupling lines first (behind signals)
            const signalPositions = {};
            Object.entries(manifoldData.signals).forEach(([signalId, signalData]) => {
                if (signalData.trajectory[idx]) {
                    const pos = signalData.trajectory[idx];
                    signalPositions[signalId] = {
                        x: centerX + pos[0] * scale,
                        y: centerY - pos[2] * scale,
                        role: signalData.role
                    };
                }
            });

            // Draw coupling lines
            const couplings = [
                ['PS1', 'FS1', 0.8],
                ['PS1', 'FS2', 0.6],
                ['PS1', 'TS1', 0.4],
                ['TS1', 'FS2', 0.5]
            ];

            couplings.forEach(([from, to, strength]) => {
                const fromPos = signalPositions[from];
                const toPos = signalPositions[to];
                if (fromPos && toPos) {
                    // Gradient line
                    const gradient = sliceCtx.createLinearGradient(
                        fromPos.x, fromPos.y, toPos.x, toPos.y
                    );
                    gradient.addColorStop(0, `rgba(255, 107, 107, ${strength * 0.5})`);
                    gradient.addColorStop(1, `rgba(78, 205, 196, ${strength * 0.5})`);

                    sliceCtx.strokeStyle = gradient;
                    sliceCtx.lineWidth = strength * 3;
                    sliceCtx.beginPath();
                    sliceCtx.moveTo(fromPos.x, fromPos.y);
                    sliceCtx.lineTo(toPos.x, toPos.y);
                    sliceCtx.stroke();

                    // Animated particles along coupling lines
                    const particleT = (currentTime * 0.1) % 1;
                    const px = fromPos.x + (toPos.x - fromPos.x) * particleT;
                    const py = fromPos.y + (toPos.y - fromPos.y) * particleT;

                    sliceCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    sliceCtx.beginPath();
                    sliceCtx.arc(px, py, 3, 0, Math.PI * 2);
                    sliceCtx.fill();
                }
            });

            // Draw signals
            Object.entries(signalPositions).forEach(([signalId, pos]) => {
                const signalData = manifoldData.signals[signalId];
                const color = signalData.color;

                // Glow
                const gradient = sliceCtx.createRadialGradient(
                    pos.x, pos.y, 0, pos.x, pos.y, 30
                );
                gradient.addColorStop(0, color + '40');
                gradient.addColorStop(1, 'transparent');
                sliceCtx.fillStyle = gradient;
                sliceCtx.beginPath();
                sliceCtx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
                sliceCtx.fill();

                // Core
                sliceCtx.fillStyle = color;
                sliceCtx.beginPath();
                sliceCtx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
                sliceCtx.fill();

                // Label
                sliceCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                sliceCtx.font = '11px Inter, sans-serif';
                sliceCtx.textAlign = 'center';
                sliceCtx.fillText(signalId, pos.x, pos.y - 16);
            });

            // Update signal count
            document.getElementById('slice-signals').textContent =
                Object.keys(signalPositions).length;

            // Calculate density (mock)
            const point = manifoldData.trajectory[idx];
            if (point) {
                const density = point.coherence > 0.7 ? 'High' :
                               point.coherence > 0.4 ? 'Medium' : 'Low';
                document.getElementById('slice-density').textContent = density;
            }
        }

        // ============================================================================
        // CONTROLS & INTERACTIONS
        // ============================================================================

        function setupControls() {
            // Playback buttons
            document.getElementById('btn-play').addEventListener('click', togglePlay);
            document.getElementById('btn-start').addEventListener('click', () => goToTime(0));
            document.getElementById('btn-end').addEventListener('click', () =>
                goToTime(manifoldData.trajectory.length - 1));
            document.getElementById('btn-back').addEventListener('click', () =>
                goToTime(Math.max(0, currentTime - 10)));
            document.getElementById('btn-forward').addEventListener('click', () =>
                goToTime(Math.min(manifoldData.trajectory.length - 1, currentTime + 10)));

            // Timeline slider
            document.getElementById('timeline').addEventListener('input', (e) => {
                goToTime(parseInt(e.target.value));
            });

            // Speed selector
            document.getElementById('speed-select').addEventListener('change', (e) => {
                playbackSpeed = parseFloat(e.target.value);
            });

            // Slice mode buttons
            document.querySelectorAll('.slice-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.slice-mode-btn').forEach(b =>
                        b.classList.remove('active'));
                    btn.classList.add('active');
                    sliceMode = btn.dataset.mode;
                    renderSlice();
                });
            });

            // Slice canvas scroll (move slice plane)
            document.getElementById('slice-canvas').addEventListener('wheel', (e) => {
                e.preventDefault();
                slicePosition += e.deltaY * 0.01;
                slicePosition = Math.max(-5, Math.min(5, slicePosition));

                slicePlane.position.y = slicePosition;
                slicePlaneHelper.position.y = slicePosition;

                document.getElementById('slice-position').textContent =
                    `Z = ${slicePosition.toFixed(2)}`;
                renderSlice();
            });

            // Raycaster for click interactions
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('click', (event) => {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Check signal intersections
                const signalObjects = Object.values(signalMeshes);
                const intersects = raycaster.intersectObjects(signalObjects);

                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    showSignalPanel(hit.userData.signalId);
                }
            });
        }

        function setupInfoPanel() {
            document.getElementById('panel-close').addEventListener('click', () => {
                document.getElementById('info-panel').classList.remove('visible');
            });
        }

        function showSignalPanel(signalId) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('panel-content');
            const signal = manifoldData.signals[signalId];
            const idx = Math.floor(currentTime);
            const point = manifoldData.trajectory[idx];

            document.getElementById('panel-title').textContent = `Signal: ${signalId}`;

            const roleClass = signal.role.toLowerCase();

            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Role</span>
                    <span class="role-badge ${roleClass}">
                        <span class="role-indicator ${roleClass}"></span>
                        ${signal.role}
                    </span>
                </div>

                <div class="info-row">
                    <span class="info-label">Coherence</span>
                    <div class="progress-bar">
                        <div class="progress-fill ${point.coherence > 0.7 ? 'stable' : point.coherence > 0.4 ? 'warning' : 'critical'}"
                             style="width: ${point.coherence * 100}%"></div>
                    </div>
                    <span class="info-value" style="margin-left: 8px">${point.coherence.toFixed(2)}</span>
                </div>

                <div class="info-row">
                    <span class="info-label">Regime</span>
                    <span class="regime-indicator">
                        <span class="regime-dot ${point.regime}"></span>
                        ${point.regime.toUpperCase()}
                    </span>
                </div>

                <div class="info-divider"></div>

                <div style="margin-bottom: 12px">
                    <div class="info-label" style="margin-bottom: 8px">Typology</div>
                    <div class="info-row">
                        <span class="info-label">Persistence</span>
                        <span class="info-value">Trending</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Structure</span>
                        <span class="info-value">Deterministic</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Memory</span>
                        <span class="info-value">Long (H=0.72)</span>
                    </div>
                </div>

                <div class="info-divider"></div>

                <div class="info-row">
                    <span class="info-label">Drives</span>
                    <span class="info-value">FS1, FS2, TS1</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Driven by</span>
                    <span class="info-value">(none)</span>
                </div>

                <button class="view-detail-btn">View Full Analysis &rarr;</button>
            `;

            panel.classList.add('visible');
        }

        // ============================================================================
        // RESIZE HANDLER
        // ============================================================================

        function onWindowResize() {
            const container = document.getElementById('manifold-canvas').parentElement;

            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(container.clientWidth, container.clientHeight);
            composer.setSize(container.clientWidth, container.clientHeight);
        }

        // ============================================================================
        // START
        // ============================================================================

        init();
    </script>
</body>
</html>

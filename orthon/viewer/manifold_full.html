<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORTHON Phase Space Manifold</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --stable: #3182ce;
            --stable-dark: #1a365d;
            --transitional: #d69e2e;
            --transitional-dark: #744210;
            --critical: #e53e3e;
            --critical-dark: #742a2a;
            --recovery: #48bb78;
            --recovery-dark: #22543d;
            --source: #ff6b6b;
            --sink: #4ecdc4;
            --conduit: #a0aec0;
            --bg-dark: #0a0a0f;
            --bg-panel: rgba(15, 15, 25, 0.92);
            --text-primary: rgba(255, 255, 255, 0.9);
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            background: var(--bg-dark);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 24px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            z-index: 100;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
            background: linear-gradient(135deg, #fff 0%, #a0aec0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .header-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* 3D Panel */
        .manifold-panel {
            flex: 6;
            position: relative;
            background: var(--bg-dark);
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 2D Slice Panel */
        .slice-panel {
            flex: 4;
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border);
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            min-width: 320px;
        }

        .slice-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .slice-header h2 {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .slice-modes {
            display: flex;
            gap: 8px;
        }

        .slice-mode-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-tertiary);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .slice-mode-btn:hover {
            color: var(--text-secondary);
        }

        .slice-mode-btn.active {
            background: rgba(49, 130, 206, 0.15);
            border-color: var(--stable);
            color: var(--stable);
        }

        .slice-canvas-container {
            flex: 1;
            position: relative;
            padding: 16px;
        }

        #slice-canvas {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
        }

        .slice-info {
            padding: 14px 20px;
            border-top: 1px solid var(--border);
            font-size: 12px;
        }

        .slice-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .slice-info-label { color: var(--text-tertiary); }
        .slice-info-value {
            color: var(--text-primary);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        /* Timeline */
        .timeline-panel {
            padding: 14px 24px 18px;
            border-top: 1px solid var(--border);
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 14px;
        }

        .playback-btns {
            display: flex;
            gap: 4px;
        }

        .playback-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 34px;
            height: 34px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .playback-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .playback-btn.active {
            background: var(--stable);
            border-color: var(--stable);
            color: white;
        }

        .timeline-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            cursor: pointer;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--stable);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(49, 130, 206, 0.6);
            transition: transform 0.1s;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .time-display {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 70px;
        }

        .speed-select {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        /* Regime Ribbon */
        .regime-ribbon {
            display: flex;
            height: 28px;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }

        .regime-segment {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .regime-segment:hover { filter: brightness(1.2); }
        .regime-segment.stable { background: var(--stable-dark); color: var(--stable); }
        .regime-segment.transitional { background: var(--transitional-dark); color: var(--transitional); }
        .regime-segment.critical { background: var(--critical-dark); color: var(--critical); }
        .regime-segment.recovery { background: var(--recovery-dark); color: var(--recovery); }

        .regime-segment.current {
            transform: scaleY(1.15);
            filter: brightness(1.3);
            box-shadow: 0 0 15px currentColor;
        }

        /* Legend */
        .signal-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 16px;
            padding: 12px 18px;
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .legend-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .legend-title {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
            margin-bottom: 2px;
        }

        .legend-divider {
            width: 1px;
            background: var(--border);
            margin: 0 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .legend-dot.source { background: var(--source); box-shadow: 0 0 8px var(--source); }
        .legend-dot.sink { background: var(--sink); box-shadow: 0 0 8px var(--sink); }
        .legend-dot.conduit { background: var(--conduit); }
        .legend-dot.stable { background: var(--stable); box-shadow: 0 0 8px var(--stable); }
        .legend-dot.transitional { background: var(--transitional); box-shadow: 0 0 8px var(--transitional); }
        .legend-dot.critical { background: var(--critical); box-shadow: 0 0 8px var(--critical); }

        /* Info Panel */
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            transform: translateX(340px);
            opacity: 0;
            transition: all 0.3s ease-out;
            z-index: 50;
        }

        .info-panel.visible {
            transform: translateX(0);
            opacity: 1;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 18px;
            border-bottom: 1px solid var(--border);
            background: rgba(0,0,0,0.2);
        }

        .info-panel-title {
            font-size: 14px;
            font-weight: 600;
        }

        .info-panel-close {
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .info-panel-close:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
        }

        .info-panel-content {
            padding: 18px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }

        .info-label {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .info-value {
            font-size: 13px;
            font-family: 'SF Mono', monospace;
        }

        .info-divider {
            height: 1px;
            background: var(--border);
            margin: 18px 0;
        }

        .role-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 12px;
            border-radius: 14px;
            font-size: 11px;
            font-weight: 600;
        }

        .role-badge.source { background: rgba(255, 107, 107, 0.2); color: var(--source); }
        .role-badge.sink { background: rgba(78, 205, 196, 0.2); color: var(--sink); }
        .role-badge.conduit { background: rgba(160, 174, 192, 0.2); color: var(--conduit); }

        .role-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .role-dot.source { background: var(--source); }
        .role-dot.sink { background: var(--sink); }
        .role-dot.conduit { background: var(--conduit); }

        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            flex: 1;
            margin: 0 12px;
        }

        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .progress-fill.high { background: linear-gradient(90deg, var(--stable) 0%, #63b3ed 100%); }
        .progress-fill.medium { background: linear-gradient(90deg, var(--transitional) 0%, #f6e05e 100%); }
        .progress-fill.low { background: linear-gradient(90deg, var(--critical) 0%, #fc8181 100%); }

        .regime-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .regime-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .regime-dot.stable { background: var(--stable); box-shadow: 0 0 10px var(--stable); }
        .regime-dot.transitional { background: var(--transitional); box-shadow: 0 0 10px var(--transitional); }
        .regime-dot.critical { background: var(--critical); box-shadow: 0 0 10px var(--critical); }

        .detail-btn {
            width: 100%;
            padding: 12px;
            background: rgba(49, 130, 206, 0.1);
            border: 1px solid var(--stable);
            color: var(--stable);
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            margin-top: 10px;
        }

        .detail-btn:hover {
            background: rgba(49, 130, 206, 0.2);
        }

        /* View controls */
        .view-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .view-btn {
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
        }

        .view-btn.active {
            border-color: var(--stable);
            color: var(--stable);
        }

        /* Stats overlay */
        .stats-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 16px;
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 11px;
            font-family: 'SF Mono', monospace;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 4px;
        }

        .stats-label { color: var(--text-tertiary); }
        .stats-value { color: var(--text-primary); }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>ORTHON Phase Space Manifold</h1>
            <div class="header-actions">
                <button class="header-btn" id="resetBtn">Reset View</button>
                <button class="header-btn" id="exportBtn">Export</button>
            </div>
        </header>

        <div class="main-content">
            <div class="manifold-panel">
                <canvas id="canvas"></canvas>

                <div class="view-controls">
                    <button class="view-btn active" data-view="orbit">Orbit</button>
                    <button class="view-btn" data-view="top">Top</button>
                    <button class="view-btn" data-view="side">Side</button>
                    <button class="view-btn" data-view="follow">Follow</button>
                </div>

                <div class="signal-legend">
                    <div class="legend-section">
                        <span class="legend-title">Signals</span>
                        <div class="legend-item">
                            <div class="legend-dot source"></div>
                            <span>SOURCE</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot sink"></div>
                            <span>SINK</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot conduit"></div>
                            <span>CONDUIT</span>
                        </div>
                    </div>
                    <div class="legend-divider"></div>
                    <div class="legend-section">
                        <span class="legend-title">Regime</span>
                        <div class="legend-item">
                            <div class="legend-dot stable"></div>
                            <span>Stable</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot transitional"></div>
                            <span>Transitional</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot critical"></div>
                            <span>Critical</span>
                        </div>
                    </div>
                </div>

                <div class="stats-overlay">
                    <div class="stats-row">
                        <span class="stats-label">Coherence</span>
                        <span class="stats-value" id="statCoherence">0.85</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Regime</span>
                        <span class="stats-value" id="statRegime">STABLE</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Signals</span>
                        <span class="stats-value">4</span>
                    </div>
                </div>

                <div class="info-panel" id="infoPanel">
                    <div class="info-panel-header">
                        <span class="info-panel-title" id="panelTitle">Signal: PS1</span>
                        <button class="info-panel-close" id="panelClose">&times;</button>
                    </div>
                    <div class="info-panel-content" id="panelContent"></div>
                </div>
            </div>

            <div class="slice-panel">
                <div class="slice-header">
                    <h2>INTERIOR SLICE</h2>
                    <div class="slice-modes">
                        <button class="slice-mode-btn active" data-mode="spatial">Spatial</button>
                        <button class="slice-mode-btn" data-mode="temporal">Temporal</button>
                    </div>
                </div>
                <div class="slice-canvas-container">
                    <canvas id="slice-canvas"></canvas>
                </div>
                <div class="slice-info">
                    <div class="slice-info-row">
                        <span class="slice-info-label">Slice Position</span>
                        <span class="slice-info-value" id="slicePos">Z = 0.00</span>
                    </div>
                    <div class="slice-info-row">
                        <span class="slice-info-label">Signals in View</span>
                        <span class="slice-info-value" id="sliceSignals">4</span>
                    </div>
                    <div class="slice-info-row">
                        <span class="slice-info-label">Local Density</span>
                        <span class="slice-info-value" id="sliceDensity">High</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="timeline-panel">
            <div class="timeline-controls">
                <div class="playback-btns">
                    <button class="playback-btn" id="btnStart" title="Start">&#8676;</button>
                    <button class="playback-btn" id="btnBack" title="Back">&#9664;</button>
                    <button class="playback-btn" id="btnPlay" title="Play">&#9654;</button>
                    <button class="playback-btn" id="btnForward" title="Forward">&#9654;</button>
                    <button class="playback-btn" id="btnEnd" title="End">&#8677;</button>
                </div>
                <input type="range" class="timeline-slider" id="timeline" min="0" max="499" value="0">
                <span class="time-display" id="timeDisplay">t = 0</span>
                <select class="speed-select" id="speedSelect">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="5">5x</option>
                </select>
            </div>
            <div class="regime-ribbon" id="regimeRibbon"></div>
        </div>
    </div>

    <!-- Three.js with modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ============================================================
        // State
        // ============================================================
        let scene, camera, renderer, controls, composer, bloomPass;
        let trajectoryMesh, signalMeshes = [], basinMeshes = [];
        let manifoldData, currentTime = 0, isPlaying = false, playbackSpeed = 1;
        let sliceCtx, slicePosition = 0;
        let selectedSignal = null;
        let viewMode = 'orbit';

        // ============================================================
        // Load Data from JSON
        // ============================================================
        async function loadData() {
            try {
                const response = await fetch('data/manifold.json');
                if (!response.ok) throw new Error('Failed to load manifold.json');
                const data = await response.json();

                // Transform signals from object to array format
                const signalArray = Object.entries(data.signals).map(([id, sig], idx) => ({
                    id,
                    role: sig.role || 'CONDUIT',
                    color: sig.color || '#a0aec0',
                    trajectory: sig.trajectory || [],
                    drives: [],
                    drivenBy: [],
                    typology: {
                        persistence: 'Trending',
                        hurst: 0.65 + Math.random() * 0.2,
                        structure: 'Deterministic',
                        entropy: 0.7 + Math.random() * 0.2,
                        memory: 'Medium',
                        tau: 15 + idx * 2
                    }
                }));

                // Build couplings based on roles
                const couplings = [];
                const sources = signalArray.filter(s => s.role === 'SOURCE');
                const sinks = signalArray.filter(s => s.role === 'SINK');
                sources.forEach(src => {
                    sinks.slice(0, 2).forEach(sink => {
                        couplings.push({ from: src.id, to: sink.id, strength: 0.6 + Math.random() * 0.3 });
                    });
                });

                console.log(`Loaded: ${data.trajectory.length} trajectory points, ${signalArray.length} signals`);
                console.log(`Source: ${data.metadata?.source || 'Unknown'}`);

                return {
                    trajectory: data.trajectory,
                    signals: signalArray,
                    couplings,
                    basins: data.basins || [],
                    metadata: data.metadata
                };
            } catch (e) {
                console.warn('Could not load manifold.json, using generated data:', e);
                return generateFallbackData();
            }
        }

        function generateFallbackData() {
            // Lorenz attractor fallback
            const trajectory = [];
            const sigma = 10, rho = 28, beta = 8/3;
            let x = 1, y = 1, z = 1;
            const dt = 0.01, scale = 0.15;

            for (let i = 0; i < 500; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;
                x += dx * dt; y += dy * dt; z += dz * dt;

                let regime = 'stable', coherence = 0.85;
                if (z > 30) { regime = 'transitional'; coherence = 0.65; }
                if (Math.abs(x) > 15 && z > 35) { regime = 'critical'; coherence = 0.32; }

                trajectory.push({ t: i, position: [x * scale, (z - 25) * scale, y * scale], regime, coherence });
            }

            const signals = [
                { id: 'PS1', role: 'SOURCE', color: '#ff6b6b' },
                { id: 'FS1', role: 'SINK', color: '#4ecdc4' },
                { id: 'FS2', role: 'SINK', color: '#4ecdc4' },
                { id: 'TS1', role: 'CONDUIT', color: '#a0aec0' }
            ].map((def, idx) => ({
                ...def,
                trajectory: trajectory.map((t, i) => [
                    t.position[0] + Math.sin(i * 0.1 + idx * 1.5) * 0.35,
                    t.position[1] + Math.cos(i * 0.12 + idx * 1.2) * 0.28,
                    t.position[2] + Math.sin(i * 0.11 + idx * 0.9) * 0.32
                ]),
                typology: { persistence: 'Trending', hurst: 0.72, structure: 'Deterministic', entropy: 0.81, memory: 'Long', tau: 23 }
            }));

            return { trajectory, signals, couplings: [{ from: 'PS1', to: 'FS1', strength: 0.85 }] };
        }

        // ============================================================
        // Initialize
        // ============================================================
        async function init() {
            manifoldData = await loadData();

            // Update header with source info
            if (manifoldData.metadata?.source) {
                document.querySelector('.header h1').textContent =
                    `ORTHON Phase Space: ${manifoldData.metadata.source}`;
            }

            initThreeJS();
            initSliceCanvas();
            buildScene();
            buildRegimeRibbon();
            setupControls();

            animate();
        }

        function initThreeJS() {
            const canvas = document.getElementById('canvas');
            const container = canvas.parentElement;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.FogExp2(0x050510, 0.045);

            // Camera
            camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 7, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.4;
            controls.maxDistance = 30;
            controls.minDistance = 3;

            // Lights
            scene.add(new THREE.AmbientLight(0x303050, 0.6));

            const keyLight = new THREE.DirectionalLight(0xaaccff, 1.0);
            keyLight.position.set(5, 12, 8);
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xffaa66, 0.5);
            fillLight.position.set(-8, -4, -6);
            scene.add(fillLight);

            const rimLight = new THREE.PointLight(0x6688ff, 0.8, 25);
            rimLight.position.set(-10, 5, 0);
            scene.add(rimLight);

            // Post-processing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(container.clientWidth, container.clientHeight),
                1.2,   // strength
                0.5,   // radius
                0.7    // threshold
            );
            composer.addPass(bloomPass);

            // Resize
            window.addEventListener('resize', onResize);
        }

        function initSliceCanvas() {
            const canvas = document.getElementById('slice-canvas');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            sliceCtx = canvas.getContext('2d');

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                slicePosition = Math.max(-4, Math.min(4, slicePosition + e.deltaY * 0.01));
                document.getElementById('slicePos').textContent = `Z = ${slicePosition.toFixed(2)}`;
                renderSlice();
            });
        }

        // ============================================================
        // Build Scene
        // ============================================================
        function buildScene() {
            // Grid
            const grid = new THREE.GridHelper(24, 48, 0x151525, 0x0a0a15);
            grid.position.y = -4;
            scene.add(grid);

            // Trajectory
            buildTrajectory();

            // Signals
            buildSignals();

            // Basins
            buildBasins();
        }

        function buildTrajectory() {
            const points = manifoldData.trajectory.map(t => new THREE.Vector3(...t.position));

            // Vertex colors by regime
            const colors = [];
            const regimeColors = {
                stable: new THREE.Color(0x3182ce),
                transitional: new THREE.Color(0xd69e2e),
                critical: new THREE.Color(0xe53e3e),
                recovery: new THREE.Color(0x48bb78)
            };

            manifoldData.trajectory.forEach(t => {
                const color = regimeColors[t.regime] || regimeColors.stable;
                colors.push(color.r, color.g, color.b);
            });

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2
            });

            trajectoryMesh = new THREE.Line(geometry, material);
            scene.add(trajectoryMesh);

            // Add small dots at intervals
            const dotGeom = new THREE.SphereGeometry(0.03, 6, 6);
            for (let i = 0; i < points.length; i += 30) {
                const regime = manifoldData.trajectory[i].regime;
                const color = regimeColors[regime] || regimeColors.stable;
                const dotMat = new THREE.MeshBasicMaterial({ color: color });
                const dot = new THREE.Mesh(dotGeom, dotMat);
                dot.position.copy(points[i]);
                scene.add(dot);
            }
        }

        function buildSignals() {
            const geometry = new THREE.SphereGeometry(0.05, 12, 12);

            manifoldData.signals.forEach(signal => {
                const color = new THREE.Color(signal.color);

                const material = new THREE.MeshBasicMaterial({
                    color: color
                });

                const mesh = new THREE.Mesh(geometry, material);
                if (signal.trajectory && signal.trajectory.length > 0) {
                    mesh.position.set(...signal.trajectory[0]);
                }
                mesh.userData = signal;
                signalMeshes.push(mesh);
                scene.add(mesh);
            });
        }

        function buildBasins() {
            // Use basins from loaded data, or default
            const basinData = manifoldData.basins?.length > 0 ? manifoldData.basins : [
                { centroid: [-1.5, 0.5, 0], radius: 2.5, regime: 'stable' },
                { centroid: [1.5, 0.5, 0], radius: 2.5, regime: 'transitional' }
            ];

            const regimeColors = {
                stable: 0x3182ce,
                transitional: 0xd69e2e,
                critical: 0xe53e3e,
                recovery: 0x48bb78
            };

            basinData.forEach(basin => {
                const center = basin.centroid || basin.center || [0, 0, 0];
                const radius = basin.radius || 2;
                const regime = basin.regime || 'stable';

                const geometry = new THREE.SphereGeometry(radius, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: regimeColors[regime] || 0x3182ce,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...center);
                basinMeshes.push(mesh);
                scene.add(mesh);
            });
        }

        // ============================================================
        // Regime Ribbon
        // ============================================================
        function buildRegimeRibbon() {
            const ribbon = document.getElementById('regimeRibbon');
            const step = Math.ceil(manifoldData.trajectory.length / 25);

            for (let i = 0; i < manifoldData.trajectory.length; i += step) {
                const seg = document.createElement('div');
                seg.className = `regime-segment ${manifoldData.trajectory[i].regime}`;
                seg.dataset.idx = i;
                seg.onclick = () => goToTime(i);
                ribbon.appendChild(seg);
            }
        }

        function updateRegimeRibbon() {
            const step = Math.ceil(manifoldData.trajectory.length / 25);
            document.querySelectorAll('.regime-segment').forEach((seg, i) => {
                const segTime = i * step;
                seg.classList.toggle('current', currentTime >= segTime && currentTime < segTime + step);
            });
        }

        // ============================================================
        // Controls
        // ============================================================
        function setupControls() {
            // Playback
            document.getElementById('btnPlay').onclick = togglePlay;
            document.getElementById('btnStart').onclick = () => goToTime(0);
            document.getElementById('btnEnd').onclick = () => goToTime(manifoldData.trajectory.length - 1);
            document.getElementById('btnBack').onclick = () => goToTime(Math.max(0, currentTime - 20));
            document.getElementById('btnForward').onclick = () => goToTime(Math.min(manifoldData.trajectory.length - 1, currentTime + 20));

            document.getElementById('timeline').oninput = (e) => goToTime(parseInt(e.target.value));
            document.getElementById('speedSelect').onchange = (e) => playbackSpeed = parseFloat(e.target.value);

            // View buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setViewMode(btn.dataset.view);
                };
            });

            // Reset
            document.getElementById('resetBtn').onclick = () => {
                camera.position.set(10, 7, 10);
                controls.target.set(0, 0, 0);
                controls.autoRotate = true;
            };

            // Slice modes
            document.querySelectorAll('.slice-mode-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.slice-mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    renderSlice();
                };
            });

            // Panel close
            document.getElementById('panelClose').onclick = () => {
                document.getElementById('infoPanel').classList.remove('visible');
                selectedSignal = null;
            };

            // Raycaster for clicks
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('click', (e) => {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(signalMeshes);

                if (hits.length > 0) {
                    const signal = hits[0].object.userData;
                    showSignalPanel(signal);
                }
            });
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('btnPlay');
            btn.classList.toggle('active', isPlaying);
            btn.innerHTML = isPlaying ? '&#10074;&#10074;' : '&#9654;';
            controls.autoRotate = !isPlaying;
        }

        function goToTime(t) {
            currentTime = Math.floor(t);
            document.getElementById('timeline').value = currentTime;
            document.getElementById('timeDisplay').textContent = `t = ${currentTime}`;

            const point = manifoldData.trajectory[currentTime];

            // Update signals
            signalMeshes.forEach(mesh => {
                const pos = mesh.userData.trajectory[currentTime];
                if (pos) {
                    mesh.position.set(...pos);
                    // Breathing effect
                    const breathe = 1 + Math.sin(currentTime * 0.1 + mesh.userData.id.charCodeAt(2)) * 0.08;
                    mesh.scale.setScalar(breathe);
                }
            });

            // Update stats
            document.getElementById('statCoherence').textContent = point.coherence.toFixed(2);
            document.getElementById('statRegime').textContent = point.regime.toUpperCase();
            document.getElementById('statRegime').style.color = `var(--${point.regime})`;

            // Update ribbon
            updateRegimeRibbon();

            // Update slice
            renderSlice();

            // Follow mode
            if (viewMode === 'follow') {
                const pos = new THREE.Vector3(...point.position);
                controls.target.lerp(pos, 0.1);
            }
        }

        function setViewMode(mode) {
            viewMode = mode;
            controls.autoRotate = mode === 'orbit';

            const presets = {
                orbit: { pos: [10, 7, 10], target: [0, 0, 0] },
                top: { pos: [0, 15, 0], target: [0, 0, 0] },
                side: { pos: [15, 0, 0], target: [0, 0, 0] },
                follow: { pos: camera.position.toArray(), target: [0, 0, 0] }
            };

            if (presets[mode]) {
                const p = presets[mode];
                camera.position.set(...p.pos);
                controls.target.set(...p.target);
            }
        }

        // ============================================================
        // Info Panel
        // ============================================================
        function showSignalPanel(signal) {
            selectedSignal = signal;
            const panel = document.getElementById('infoPanel');
            const content = document.getElementById('panelContent');
            const point = manifoldData.trajectory[Math.floor(currentTime)];

            document.getElementById('panelTitle').textContent = `Signal: ${signal.id}`;

            const roleClass = signal.role.toLowerCase();
            const coherenceLevel = point.coherence > 0.7 ? 'high' : point.coherence > 0.4 ? 'medium' : 'low';

            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Role</span>
                    <span class="role-badge ${roleClass}">
                        <span class="role-dot ${roleClass}"></span>
                        ${signal.role}
                    </span>
                </div>

                <div class="info-row">
                    <span class="info-label">Coherence</span>
                    <div class="progress-bar">
                        <div class="progress-fill ${coherenceLevel}" style="width: ${point.coherence * 100}%"></div>
                    </div>
                    <span class="info-value">${point.coherence.toFixed(2)}</span>
                </div>

                <div class="info-row">
                    <span class="info-label">Regime</span>
                    <span class="regime-indicator">
                        <span class="regime-dot ${point.regime}"></span>
                        <span style="color: var(--${point.regime})">${point.regime.toUpperCase()}</span>
                    </span>
                </div>

                <div class="info-divider"></div>

                <div style="margin-bottom: 16px">
                    <div class="info-label" style="margin-bottom: 10px; font-weight: 500;">Typology Profile</div>
                    <div class="info-row">
                        <span class="info-label">Persistence</span>
                        <span class="info-value">${signal.typology.persistence} (H=${signal.typology.hurst.toFixed(2)})</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Structure</span>
                        <span class="info-value">${signal.typology.structure} (${signal.typology.entropy.toFixed(2)})</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Memory</span>
                        <span class="info-value">${signal.typology.memory} (\u03C4=${signal.typology.tau})</span>
                    </div>
                </div>

                <div class="info-divider"></div>

                <div class="info-row">
                    <span class="info-label">Drives</span>
                    <span class="info-value">${signal.drives ? signal.drives.join(', ') : '(none)'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Driven by</span>
                    <span class="info-value">${signal.drivenBy ? signal.drivenBy.join(', ') : '(none)'}</span>
                </div>

                <button class="detail-btn">View Full Analysis &rarr;</button>
            `;

            panel.classList.add('visible');
        }

        // ============================================================
        // 2D Slice
        // ============================================================
        function renderSlice() {
            if (!sliceCtx) return;

            const w = sliceCtx.canvas.width;
            const h = sliceCtx.canvas.height;
            const t = Math.floor(currentTime);
            const point = manifoldData.trajectory[t];

            // Clear
            sliceCtx.fillStyle = '#08080c';
            sliceCtx.fillRect(0, 0, w, h);

            // Grid
            sliceCtx.strokeStyle = 'rgba(255,255,255,0.04)';
            sliceCtx.lineWidth = 1;
            for (let x = 0; x < w; x += 30) {
                sliceCtx.beginPath();
                sliceCtx.moveTo(x, 0);
                sliceCtx.lineTo(x, h);
                sliceCtx.stroke();
            }
            for (let y = 0; y < h; y += 30) {
                sliceCtx.beginPath();
                sliceCtx.moveTo(0, y);
                sliceCtx.lineTo(w, y);
                sliceCtx.stroke();
            }

            const scale = 45, cx = w / 2, cy = h / 2;
            const positions = {};

            // Get signal positions
            manifoldData.signals.forEach(signal => {
                const pos = signal.trajectory[t];
                positions[signal.id] = {
                    x: cx + pos[0] * scale,
                    y: cy - pos[2] * scale,
                    signal
                };
            });

            // Draw coupling lines with animated particles
            manifoldData.couplings.forEach(coupling => {
                const p1 = positions[coupling.from];
                const p2 = positions[coupling.to];
                if (!p1 || !p2) return;

                // Line gradient
                const grad = sliceCtx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                grad.addColorStop(0, `rgba(255,107,107,${coupling.strength * 0.5})`);
                grad.addColorStop(1, `rgba(78,205,196,${coupling.strength * 0.5})`);

                sliceCtx.strokeStyle = grad;
                sliceCtx.lineWidth = coupling.strength * 4;
                sliceCtx.beginPath();
                sliceCtx.moveTo(p1.x, p1.y);
                sliceCtx.lineTo(p2.x, p2.y);
                sliceCtx.stroke();

                // Animated particle
                const particleT = (currentTime * 0.05) % 1;
                const px = p1.x + (p2.x - p1.x) * particleT;
                const py = p1.y + (p2.y - p1.y) * particleT;

                sliceCtx.fillStyle = 'rgba(255,255,255,0.9)';
                sliceCtx.shadowColor = '#fff';
                sliceCtx.shadowBlur = 8;
                sliceCtx.beginPath();
                sliceCtx.arc(px, py, 3, 0, Math.PI * 2);
                sliceCtx.fill();
                sliceCtx.shadowBlur = 0;
            });

            // Draw signals as small dots
            Object.values(positions).forEach(p => {
                const isSelected = selectedSignal && selectedSignal.id === p.signal.id;
                const baseSize = isSelected ? 6 : 4;

                // Subtle glow
                const glowGrad = sliceCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 15);
                glowGrad.addColorStop(0, p.signal.color + '40');
                glowGrad.addColorStop(1, 'transparent');
                sliceCtx.fillStyle = glowGrad;
                sliceCtx.beginPath();
                sliceCtx.arc(p.x, p.y, 15, 0, Math.PI * 2);
                sliceCtx.fill();

                // Core dot
                sliceCtx.fillStyle = p.signal.color;
                sliceCtx.shadowColor = p.signal.color;
                sliceCtx.shadowBlur = 8;
                sliceCtx.beginPath();
                sliceCtx.arc(p.x, p.y, baseSize, 0, Math.PI * 2);
                sliceCtx.fill();
                sliceCtx.shadowBlur = 0;

                // Selection ring
                if (isSelected) {
                    sliceCtx.strokeStyle = '#fff';
                    sliceCtx.lineWidth = 1;
                    sliceCtx.beginPath();
                    sliceCtx.arc(p.x, p.y, baseSize + 4, 0, Math.PI * 2);
                    sliceCtx.stroke();
                }
            });

            // Update info
            document.getElementById('sliceSignals').textContent = Object.keys(positions).length;
            document.getElementById('sliceDensity').textContent =
                point.coherence > 0.7 ? 'High' : point.coherence > 0.4 ? 'Medium' : 'Low';
        }

        // ============================================================
        // Animation Loop
        // ============================================================
        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                currentTime = (currentTime + playbackSpeed * 0.5) % manifoldData.trajectory.length;
                goToTime(currentTime);
            }

            controls.update();
            composer.render();
        }

        function onResize() {
            const container = document.getElementById('canvas').parentElement;

            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(container.clientWidth, container.clientHeight);
            composer.setSize(container.clientWidth, container.clientHeight);

            const sc = document.getElementById('slice-canvas');
            const scContainer = sc.parentElement;
            sc.width = scContainer.clientWidth;
            sc.height = scContainer.clientHeight;
            renderSlice();
        }

        // ============================================================
        // Start
        // ============================================================
        init();
    </script>
</body>
</html>
